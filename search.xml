<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[博客使用方法]]></title>
      <url>%2F2017%2F02%2F07%2F%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[新建博客 $ hexo new &quot;博客名&quot; 比如： $ hexo new &quot;博客使用方法&quot; 为博客添加标签以及分类 打开/hexo/source/_posts文件夹，找到刚才新建的博客并打开 修改开头内容 title: 博客使用方法date: 2017-02-07 15:18:03tags:categories: 技巧 其中：tags即为文章的标签，可以不写，如果要添加多个标签则使用如下格式： tags:[博客,使用,方法] 每个标签后的逗号必须是英文逗号。 categories即为文章的分类 如果需要手动实现阅读全文功能，则在需要显示阅读全文按钮的地方添加&lt;!--more--&gt;，则文章会从此处截断，显示阅读全文按钮。 如果需要自动设置显示阅读全文功能，在主题文件下的_config.yml里面新增如下代码： 1234# 配置文章字数多于100字后显示阅读全文auto_excerpt: enable: true length: 100 发布博客使用如下命令即可： $ hexo clean 该命令用于清除缓存，可以忽略 $ hexo generate 该命令用户生成静态页面，可以简写为 $ hexo g 如果需要现在本地预览则使用$ hexo server或者可以简写为$ hexo s，然后运行 http://localhost:4000/即可预览。 $ hexo deploy 该命令将本地文件部署到github上，可以简写为$ hexo d]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客搬家]]></title>
      <url>%2F2017%2F01%2F20%2F%E5%8D%9A%E5%AE%A2%E6%90%AC%E5%AE%B6%2F</url>
      <content type="text"><![CDATA[​ 原来一直在CSDN上写博客，不知道是自己不会用还是怎么的，老感觉CSDN的排版很麻烦而且很不人性化。后来被简书的简介唯美风格所吸引，曾经一度想转移到简书，但是感觉简书上太杂乱，什么内容的文章都有，最近才听说有个叫GitHub Pages的神器，于是乎果断尝试，简直是相见恨晚啊。所以，以后的个人博客都将迁移到此处。 ​ 注：原CSDN博客地址：http://blog.csdn.net/zhangym90]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android使用Handler的postDelayed(Runnable, long)方法实现定时任务]]></title>
      <url>%2F2017%2F01%2F17%2FAndroid%E4%BD%BF%E7%94%A8Handler%E7%9A%84postDelayed-Runnable-long-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
      <content type="text"><![CDATA[近期由于公司领导需要将公众号的运营数据放到公司的50寸的微鲸智能电视机上播放，所以一开始是找设计作图，设计问后台要数据，然后做成图片放到电视机上。但是数据是不断更新的，所以设计作图也做的很郁闷。所以我也就顺手做了个app用来展示，顺便解放了设计。当然，功能很简单，就一个界面，背景图是设计原先做的图，然后他将数据扣掉，我在需要添加数据的地方添加几个TextView，然后后台给我一个接口，我这边联网获取数据，每分钟更新一次。 好了，废话说了那么多了，现在主要说说如何实现每分钟更新一次吧，首先创建Handler对象： 1private Handler mHandler = new Handler(); 然后是Runnable，在Runnable的run()方法中调用mHandler.postDelayed(this,60000)，实现每隔1分钟执行一次。 12345678Runnable runnable = new Runnable() &#123; @Override public void run() &#123; showData(); // 循环调用实现定时刷新界面 mHandler.postDelayed(this, 60000); &#125; &#125;; 然后启动定时器即可： 1mHandler.postDelayed(runnable, 1000);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RxJava学习笔记]]></title>
      <url>%2F2016%2F12%2F14%2FRxJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[RxJava的常用操作符 just(T...):将传入的参数依次发送出来,快捷创建创建事件队列的方法 1Observable.just("hello","world”); 等同于 12345678Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("hello"); subscriber.onNext("world"); subscriber.onCompleted(); &#125; &#125;) from(T[]) / from(Iterable) : 将传入的数组或 Iterable 拆分成具体对象后，依次发送出 12String[] words = new String[]&#123;"hello","world"&#125;; Observable.from(words); 等同于 123456789Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("hello"); subscriber.onNext("world"); subscriber.onCompleted(); &#125; &#125;) Rxjava的知识点RxJava的基本实现方式： Observable即被观察者，它决定了什么时候触发事件以及触发怎样的事件。 Observer即观察者，它决定了事件触发的时候将有怎样的行为。 123456789101112131415161718192021222324Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("hello"); subscriber.onNext("world"); subscriber.onCompleted(); &#125; &#125;) .subscribe(new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.d(TAG,"onCompleted") &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onNext(String s) &#123; Log.d(TAG,s); &#125; &#125;); 除了Observer接口之外，RxJava还内置了一个实现了Observer的抽象类：Subscriber. 123456789101112131415161718192021222324Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("hello"); subscriber.onNext("world"); subscriber.onCompleted(); &#125; &#125;) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.d(TAG, "onCompleted"); &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onNext(String s) &#123; Log.d(TAG, s); &#125; &#125;); 两种使用方式是一样的。它们的区别对于使用者来说主要有两点： Subscriber新增加了onStart()方法，它会在subscribe刚开始事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或者重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作有线程要求（如弹出一个转菊花的ProgressBar,就必须在主线程执行），onStart()方法就不适用了，因为它总是在subscribe所发生的线程被调用，而不能指定线程。需要在指定线程来做准备工作，可以使用doOnSubscribe()方法。 Subscriber实现了另一个方法unsubscribe(),这个方法被调用后，Subscriber将不再接收事件。一般这个方法调用前，可以使用isUnsubscribed()先判断一下状态。unsubscribe()主要用于解除引用关系，以避免内存泄露的发生。 Action 1234567891011121314151617181920212223242526272829Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; // next() Log.d(TAG,s); &#125; &#125;; Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; // ERROR &#125; &#125;; Action0 onCompletedAction = new Action0() &#123; @Override public void call() &#123; // complete Log.d(TAG,"onCompleted"); &#125; &#125;; // 自动创建Subscriber,并使用onNextAction来定义onNext()； observable.subscribe(onNextAction); // 自动创建Subscriber,并使用onNextAction onErrorAction 来定义onNext() onError() observable.subscribe(onNextAction,onErrorAction); // 自动创建Subscriber,并使用onNextAction onErrorAction onCompletedAction来定义onNext() onError() onCompleted() observable.subscribe(onNextAction,onErrorAction,onCompletedAction); Action0是RxJava的一个接口，它只有一个方法call(),这个方法是无参数无返回值的；由于onCompleted()方法也是无参数无返回值得，因此Action0可以被当成一个包装对象，将onCompleted()的内容打包起来将自己作为一个参数传入subscribe()以实现不完整定义的回调。Action1也是一个接口，它同样只有一个方法call(T t)，这个方法也无返回值，但是有一个参数；与Action0同理，由于onNext(T t)和onError(Throwable error)也是单参数无返回值的，因此Action1可以将onNext(t)和onError(error)打包。 RxJava提供了多个ActionX形式的接口，他们可以用以包装不同的无返回值的方法。ActionX的方法是无返回值的。 例如，将字符串数组names中的所有字符串依次打印出来： 12345678String[] names = new String[]&#123;"John","Jim","Tom","Alexander"&#125;; Observable.from(names) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d(TAG,s); &#125; &#125;); 线程控制 —— Scheduler 在不指定线程的情况下，RxJava遵循的是线程不变的原则，即：在哪个线程调用subscribe()，就在哪个线程产生事件；在哪个线程产生事件就在哪个线程消费事件。如果需要切换线程，就需要用到Scheduler（调度器）。RxJava通过它来指定每一段代码应该运行在什么样的线程。RxJava已经内置了几个Scheduler: Schedulers.immediate():直接在当前线程中运行，相当于不指定线程。这是默认的Scheduler。 Schedulers.newThread():总是启用新线程，并在新线程执行操作。 Schedulers.io():I/O操作（读写文件，读写数据库，联网等）所使用的Scheduler。行为模式跟newThread()的差不多，区别在于io()的内部实现是一个无数量上线的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。不要把计算工作放在io()中，可以避免创建不必要的线程。 Schedulers.computation()：计算所使用的Scheduler。这个计算指的是cpu密集型计算，即不会被I/O等操作限制性能的操作，例如图形的计算。这个Scheduler使用的是固定的线程池，大小为CPU核心数。不要把I/O操作放在computation()中，否则I/O操作的等待时间会浪费cpu。 另外，Android还有一个专用的AndroidSchedulers.mainThread()，它制定的操作将在Android主线程运行。 有了这几个Scheduler，就可以使用subscribeOn()和observeOn()两个方法来对线程进行控制。subscribeOn()指定subscribe()所发生的线程，即Observable.OnSubscribe被激活时所处的线程，或者叫做事件产生的线程。observeOn()指定Subscriber所运行在的线程。或者叫做事件的消费的线程。 123456789101112String[] names = new String[]&#123;"John","Jim","Tom","Alexander"&#125;; Observable.from(names) // 指定names发生的线程在io()线程，被创建的事件的内容names会在io线程发出 .subscribeOn(Schedulers.io()) // 指定Subscriber的回调发生在主线程，故打印将发生在主线程。 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d(TAG,s); &#125; &#125;); 事实上，这种在subscribe()之前写上两句subscribeOn(Scheduler.io())和observeOn(AndroidSchedulers.mainThread())的使用方式非常常见，它适用于多数的“后台线程取数据，主线程显示”的程序策略。 变换 所谓变化，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。 observeOn()指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次observeOn()即可。不过，不同于observeOn(),subscribeOn()的位置放在哪里都可以，但它是只能调用一次的。当使用了多个subscribeOn()的时候，只有第一个subscribeOn()起作用。 然而，虽然超过一个的subscribeOn()对事件处理的流程没有影响，但在流程之前确是可以利用的。那就是与Subscriber.onStart()方法相对应的Observable.doOnSubscribe()方法，它和Subscriber.onStart()同样是在subscribe()调用后且在事件发送前执行，但区别在于它可以指定线程。默认情况下，doOnSubscribe()执行在subscribe()发生的线程。如果在doOnSubscribe()之后有subscribeOn()方法，则它将执行离他最近的subScribeOn()所指定的线程。如下，在doOnSubscribe()后面跟一个subscribeOn()，就能指定准备工作的线程了。 123456789101112131415161718Observable.just("hello","world") .subscribeOn(Schedulers.io()) .doOnSubscribe(new Action0() &#123; @Override public void call() &#123; // 需要在主线程执行 showProgressBar(); &#125; &#125;) // 指定主线程 .subscribeOn(AndroidSchedulers.mainThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d(TAG,s); &#125; &#125;); Func 123456789101112131415Observable.just("images/sky.png") .map(new Func1&lt;String, Bitmap&gt;() &#123; @Override public Bitmap call(String s) &#123; return getBitmapFromFile(s); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; iv.setImageBitmap(bitmap); &#125; &#125;); 这里出现了一个叫做Func1的类。它和Action1非常相似，也是RxJava的一个接口，用于包装含有一个参数的方法。Func跟Action的区别在于，Func包装的是有返回值的方法。另外，和ActionX一样，FuncX也有多个，用于不同参数个数的方法。 map():事件对象的直接变换。它是RxJava最常用的变换。 flatMap():它也是把传入的参数转化之后返回另一个对象。但是跟map()不同的是，flatMap()返回的是个Observable对象，并且这个Observable对象并不是被直接发送到了Subscriber的回调方法中。 throttleFirst()：在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听事件。 ———————————♥︎举个栗子♥︎———————————— 假如我现在需要联网加载百度的页面，然后将返回的内容显示在一个TextView上，就可以这么写： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class MainActivity extends AppCompatActivity &#123; private TextView tvFirst; private TextView tvResult; private ProgressDialog dialog; private static final String TAG = "zhangym"; private Observable&lt;String&gt; mObservable; private Subscriber&lt;String&gt; mSubscriber; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvFirst = (TextView) findViewById(R.id.tv_fist); tvResult = (TextView) findViewById(R.id.tv_result); tvFirst.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; showResponseResult(); &#125; &#125;); &#125; private void showResponseResult() &#123; // 创建被观察者 mObservable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; HttpURLConnection connection = null; try &#123; URL url = new URL("https://www.baidu.com/"); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("GET"); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); InputStream is = connection.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); StringBuilder sb = new StringBuilder(); String line = null; while ((line = reader.readLine()) != null) &#123; sb.append(line); &#125; // 发送事件 subscriber.onNext(sb.toString()); subscriber.onCompleted(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); // 创建观察者 mSubscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.d(TAG, "onCompleted"); dialog.dismiss(); &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onNext(String s) &#123; tvResult.setText(s); &#125; &#125;; // 指定联网操作在io线程 mObservable.subscribeOn(Schedulers.io()) // 事件发送前的准备工作 .doOnSubscribe(new Action0() &#123; @Override public void call() &#123; dialog = new ProgressDialog(MainActivity.this, ProgressDialog.THEME_DEVICE_DEFAULT_LIGHT); dialog.setProgressStyle(ProgressDialog.STYLE_SPINNER); dialog.setIndeterminate(true); dialog.show(); &#125; &#125;) // 指定doOnSubscribe()的线程为UI线程 .subscribeOn(AndroidSchedulers.mainThread()) // 指定Subscriber的线程为UI线程，即在UI线程显示结果 .observeOn(AndroidSchedulers.mainThread()) // 订阅事件 .subscribe(mSubscriber); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // 取消订阅，防止内存泄露 if (!mSubscriber.isUnsubscribed())&#123; mSubscriber.unsubscribe(); &#125; &#125; &#125; 运行效果: 由于网速较快，所以ProgressDialog一闪而过，gif图上面看不出来。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java中回调的理解]]></title>
      <url>%2F2016%2F12%2F12%2FJava%E4%B8%AD%E5%9B%9E%E8%B0%83%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[回调在Java中运用的相当广泛，类似Android中的控件点击监听事件setOnClickListener()方法就是典型的回调。回调是什么？关于回调的定义通俗地说就是：A类调用B类中的某个方法，然后B类中反过来调用A类中的方法D,D这个方法就叫做回调方法。在Java中回调的这个方法D一般是接口中定义，然后A类通过实现接口的D方法。 一般回调的话需要满足以下几个条件： Class A实现接口CallBack callback ——场景1 class A中包含一个class B的引用b ——场景2 class B有一个参数为callback的方法f(CallBack callback) ——场景3 A里的B的引用调用B的方法 f(CallBack callback) ——A类调用B类的某个方法C ——场景4 然后b就可以在f(CallBack callback)方法中调用A的方法 ——B类调用A类的某个方法D ——场景5 接下来我将通过一个demo说明，假设我需要实现一个类似下载完成的监听方法。具体就是Download这个类可以实现下载，给它的构造方法中传入我们需要下载的数据量，其开始下载，并且提供了下载完成的监听，当下载成功或者失败后调用对应的回调方法。 首先，定义一个下载完成的接口，接口中包含了下载完成后的两个回调方法。 123456789101112131415/** * 下载完成的回调接口 * Created by zhangyongming on 2016/12/12. */ public interface OnDownloadCompleted &#123; /** * 下载成功的回调 */ void onSuccess(); /** * 下载失败的回调 */ void onFail(); &#125; 然后是Download类：Download类有一个setOnDownloadCompletedListener(OnDownloadCompleted onDownloadCompleted)方法（相当于场景3），在该方法中模拟了下载过程，并且根据下载的结果调用了Test类的onSucess()跟onFail()方法（相当于场景5，这两个方法是Test类实现了OnDownloadCompleted接口后实现的方法），在这里我们模拟如果下载结果为100则为下载成功，否则下载失败。 123456789101112131415161718192021222324252627282930/** * 模拟下载的类，里面有一个设置下载完成的监听 * Created by zhangyongming on 2016/12/12. */ public class Download &#123; private int progress; public Download(int progress) &#123; this.progress = progress; &#125; // class B有一个参数为callback的方法f(CallBack callback) ——场景3 public void setOnDownloadCompletedListener(OnDownloadCompleted onDownloadCompleted) &#123; for (int i = 0; i &lt;= progress; i++) &#123; System.out.println("下载进度： " + i + "%"); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 然后b就可以在f(CallBack callback)方法中调用A的方法 ——B类调用A类的某个方法D ——场景5 if (progress == 100) &#123; onDownloadCompleted.onSuccess(); &#125; else &#123; onDownloadCompleted.onFail(); &#125; &#125; &#125; 然后是Test类方法：Test类实现了OnDownloadCompleted接口，实现了onSuccess()方法跟onFail()方法（场景1）；Test类包含了Download类的引用（场景2），Download的实例调用了setOnDownloadCompletedListener()方法（场景4）。 12345678910111213141516171819202122232425262728293031323334/** * Class A实现接口CallBack callback ——场景1 * Created by zhangyongming on 2016/12/12. */ public class Test implements OnDownloadCompleted &#123; public static void main(String[] args) &#123; // class A中包含一个class B的引用b ——场景2 Download download = new Download(20); // A里的B的引用调用B的方法 f(CallBack callback) ——A类调用B类的某个方法C ——场景4 download.setOnDownloadCompletedListener(new Test()); &#125; @Override public void onSuccess() &#123; System.out.println("┏━━━━━┳━━━━━┓"); System.out.println("┃ ┃ ┃"); System.out.println("┃ ┃"); System.out.println("┣━ 下载完成 ━┫"); System.out.println("┃ ┃"); System.out.println("┃ ┃ ┃"); System.out.println("┗━━━━━┻━━━━━┛"); &#125; @Override public void onFail() &#123; System.out.println("┏ ━ ━ ┳ ━ ━ ┓"); System.out.println(" "); System.out.println("┃ ┃"); System.out.println(" 下载失败 "); System.out.println("┃ ┃"); System.out.println(" "); System.out.println("┗ ━ ━ ┻ ━ ━ ┛"); &#125; &#125; 上述demo我们输入一个int值之后，变开始进行循环，模拟下载过程，然后根据下载结果调用相应的方法展示数据。输出结果如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio添加日志过滤]]></title>
      <url>%2F2016%2F12%2F07%2FAndroid-Studio%E6%B7%BB%E5%8A%A0%E6%97%A5%E5%BF%97%E8%BF%87%E6%BB%A4%2F</url>
      <content type="text"><![CDATA[点击下方的 Android Monitor 点击右侧的选项菜单 点击菜单下拉列表中的 Edit Filter Configuration，打开配置界面 配置界面说明 第1部分是为这个过滤器输入名称，第2部分是一些过滤信息的配置：Log Tag 是根据log.d(&quot;XXX&quot;,&quot;show&quot;);方法中的XXX参数属性过滤，配置该项之后只会显示日志中Tag为XXX的日志;Log Message是根据日志信息过滤；Package Name是根据包名过滤；Log Level是配置显示日志的级别，一般看自己需求配置；配置完成之后点击OK确认。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac使用Dryrun做到不用运行Android Studio即可在模拟器安装预览GitHub开源项目]]></title>
      <url>%2F2016%2F12%2F06%2Fmac%E4%BD%BF%E7%94%A8Dryrun%E5%81%9A%E5%88%B0%E4%B8%8D%E7%94%A8%E8%BF%90%E8%A1%8CAndroid-Studio%E5%8D%B3%E5%8F%AF%E5%9C%A8%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AE%89%E8%A3%85%E9%A2%84%E8%A7%88GitHub%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[Dryrun是GitHub上的一个开源工具，它最强大的地方在于可以只用一行命令行即可让你运行GitHub上的项目，是不是很激动？ 通常我们需要预览GitHub上的开源项目一般会做以下几步： 找到这个项目 点击项目右侧的 Clone or download下载整个项目资源 解压缩下载下来的zip文件 导入Android Studio 同步gradle配置 如果缺少配置文件或者项目报错，则需要先排错 运行项目并预览 如果正巧是自己希望的效果，留下，如果不是，删除。 然而Dryrun只需要一行命令即可，剩下的我们都不用操心，只需安静等待即可。。。。 下面来说说如何在mac上配置吧。 首先安装前需要配置ANDROID_HOME环境变量，方法如下： 启动Terminal终端工具 输入cd ~/ 进入当前用户的home目录 或cd /Users/YourUserName 如果不存在则创建： touch .bash_profile 如果存在,就打开并编辑：open .bash_profile 在里面添加sdk的tools和platform-tools的路径,注意每个路径要用 : 隔开,并且这个路径换成你自己的刚才解压后的sdk的实际路径. 1export PATH=$PATH:/Users/youname/android/soft/adt-bundle-mac-x8664-20130522/sdk/platform-tools:/Users/youname/android/soft/adt-bundle-mac-x8664-20130522/sdk/tools(具体的文件名你自己对应) 保存关闭 更新： source .bash_profile ok了,在Terminal终端工具里输入adb -version看看,是否出来类似的界面: Android Debug Bridge version 1.0.31 如果出来了,说明已经成功了. 然后安装Dryrun，使用如下命令 $ sudo gem install dryrun 顺利的话应该就安装成功了，如果报错一般会有类似ERROR: Failed to build gem native extension. 这种错误，经过各种查资料折腾，基本上确定这个错误的一般是ruby的相关依赖文件未安装完全（网上查的，如有错误还望指正）。一般情况安装xcode后貌似就能解决，如果还是不行请自行Google或百度。安装完成后便可使用，使用方法为dryrun + 项目地址，如：dryrun https://github.com/cesarferreira/android-helloworld，接下来就是见证奇迹的时候了（图是借用dryrun官方的效果图）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Text中的属性设置]]></title>
      <url>%2F2016%2F10%2F28%2FSublime-Text%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[12345678&#123; "font_face": "Courier New", "font_size": 14.0, "update_check": false, "open_files_in_new_window": false, "hot_exit": false, "remember_open_files": false &#125; 这些配置是需要放在Preference--&gt;settings-User下的，其中 font_face 是设置字体类型的，font_size 是设置字体大小的，update_check 表示是否开启检查更新， open_files_in_new_window表示是否在新窗口中打开文件，remember_open_files 表示是否记住上次打开的文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于toolbar菜单设置了always后不显示的问题]]></title>
      <url>%2F2016%2F10%2F27%2F%E5%85%B3%E4%BA%8Etoolbar%E8%8F%9C%E5%8D%95%E8%AE%BE%E7%BD%AE%E4%BA%86always%E5%90%8E%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[我们一般写menu文件时会有如下写法： 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:id="@+id/menu011" android:title="hehe" android:icon="@mipmap/ic_launcher" android:showAsAction="always"/&gt; &lt;/menu&gt; 这样写出来的menu是不会再toolbar上面显示的，跟设置的never一样都在隐藏菜单里。解决这个问题的办法其实很简单，如下： 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;item android:id="@+id/menu_home" android:icon="@mipmap/home" app:showAsAction="always" android:title="@string/menu_home"/&gt; &lt;/menu&gt; 新增一句 1xmlns:app="http://schemas.android.com/apk/res-auto" 将 1android:showAsAction="always" 改成 1app:showAsAction="always" 即可解决。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[友盟统计sdk集成及多渠道打包]]></title>
      <url>%2F2016%2F10%2F13%2F%E5%8F%8B%E7%9B%9F%E7%BB%9F%E8%AE%A1sdk%E9%9B%86%E6%88%90%E5%8F%8A%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%2F</url>
      <content type="text"><![CDATA[友盟统计sdk集成其实很简单，先去友盟官网新建应用，然后会得到一个Appkey。 然后根据友盟的sdk集成文档在Android Studio的app目录下的build.gradle添加如下代码，集成友盟统计sdk： 12// 友盟统计的sdk compile 'com.umeng.analytics:analytics:latest.integration' 然后在AndroidManifest.xml的Application标签下配置 1234567&lt;!-- 友盟appid --&gt; &lt;meta-data android:name="UMENG_APPKEY" android:value="XXX"&gt; &lt;/meta-data&gt; &lt;!--此处配置是为了方便酷传多渠道打包 --&gt; &lt;meta-data android:value="" android:name="UMENG_CHANNEL"/&gt; 其中XXX为你自己的Appkey，UMENG_CHANNEL的值为空字符串主要是为了使用酷传的多渠道打包。然后找到程序的入口Activity，即AndroidManifest.xml里配置了如下代码的Activity 1234567&lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 在该Activity的onResum()跟onPause()方法里添加如下代码 1234567891011@Override protected void onResume() &#123; super.onResume(); MobclickAgent.onResume(this); &#125; @Override protected void onPause() &#123; super.onPause(); MobclickAgent.onPause(this); &#125; 至此，友盟统计的基本功能已经集成完毕。然后就是使用酷传进行多渠道打包了，先在酷传官网下载酷传的软件，然后申请账号，打开软件并登录 选择 上方的 工具箱 ，打开如下界面 选择 生成多渠道包，然后选择需要多渠道打包的apk文件 点击下一步，在弹出的渠道包签名对话框中选择相应的release版的keystore文件，并填写相应的信息 然后点击生成渠道包，就会出现生成渠道包的界面，完成后会在原始的apk文件所在的目录生成一个叫做 酷传智能分包 的文件夹，里面就是生成的多渠道包。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记录友盟分享，第三方登录遇到的坑]]></title>
      <url>%2F2016%2F08%2F26%2F%E8%AE%B0%E5%BD%95%E5%8F%8B%E7%9B%9F%E5%88%86%E4%BA%AB%EF%BC%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
      <content type="text"><![CDATA[最近公司项目上需要用到分享跟第三方登录，由于友盟集成的社会化分享在国内的口碑还挺不错的，所以就集成进项目了，经历了各种坑之后，基本上算是告一段落了，现在把遇到的各种坑记录下来，希望能帮到一些遇到相同问题的猿友。 坑1：QQ第三方登录的坑 QQ第三方登录需要你在腾讯开放平台申请一个AppID及Appkey ，然后才能使用，由于同一个app使用不同的签名文件生成的AppID及Appkey是不一样的，如果你给腾讯那边上传的是一个debug版的apk，那么这个AppID及Appkey就是debug版的，然后你的第三方登录只有在使用dubug版的时候才能用，在正式包下会提示错误：应用不是最新的（100044）这个错误，所以这一点一定要注意，如果你给腾讯上传的是一个release版的apk，那么你以后的每次调试QQ登录都得用release的签名打包，我的做法是，调试的时候直接用release版的签名编译，具体参考：这篇文章的做法 。 QQ的第二个坑，QQ的接口返回的唯一码是一个叫openId的东东，其实我一直不明白它为什么不返回一个QQ号啊，因为这个东西不管在哪个平台都是唯一的，算了，不扯这些了，既然人家不给返回QQ号码自然有人家的想法，也许是为了用户隐私之类的。现在就说说这个openId，据我的理解，应该是与应用的appId还有应用的签名有关（个人理解，如有错误还望指正），所以不同的应用返回的openId是不一样的，在这里我就遇到坑了，因为我们公司iOS开发的比Android早半年，所以当初ios自己用自己的账号申请了一个ios的AppID及Appkey，现在Android这边我用公司的账号在应用宝上架的app，所以同一个QQ账号的第三方登录在ios跟Android返回的openId都不一样，经过咨询腾讯客服（QQ：800013811），告诉我只有一个办法解决，那就是把一方的应用转让给另一方，保证ios的跟Android的都在一个开发者账号下，然后再申请数据互通。。。。只有这样，才能保证相同的QQ号在两个平台的openId才能一致。 坑2：新浪微博的坑 新浪这个就比较坑了，由于我用的是Android Studio，我直接将新浪的sdk里的libs下的那些so文件夹直接拷贝到我的libs里面，原以为这样就好了（貌似在ADT下确实就好了），结果运行各种闪退，日志也没啥特殊的地方，死活不知道原因，最后纠结了两天，想着可能是so文件的原因，就百度了下Android Studio如何导入so文件，按照操作执行了之后，瞬间就好了，简直汗颜。关于在Android Studio下如何导入so文件请参考：这篇文章 或者 这篇文章。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何去掉Android Studio的注释警告]]></title>
      <url>%2F2016%2F08%2F11%2F%E5%A6%82%E4%BD%95%E5%8E%BB%E6%8E%89Android-Studio%E7%9A%84%E6%B3%A8%E9%87%8A%E8%AD%A6%E5%91%8A%2F</url>
      <content type="text"><![CDATA[我们知道，使用Android Studio（以下简称AS）如果给一个方法添加文档注释时，方法里的参数也必须添加注释，否则会有警告。如下： 其实给参数添加注释是个很好的习惯，但是如果是重写的或者实现接口的抽象方法，有时候我们不需要给参数加注释，然而AS会报警告，右侧会有黄色的横条，这些警告跟代码警告混在一起，很影响阅读，所以有时候我们需要去掉。 具体步骤：File-&gt;Settings-&gt;Editor-&gt;Inspections,在右侧找到Javadoc issues下的Declaration has Javadoc problems右侧的勾去掉然后点击Apply或者OK即可。 然后就可以看到效果了。]]></content>
    </entry>

    
  
  
</search>
