<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[博客使用方法]]></title>
      <url>%2F2017%2F02%2F07%2F%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[新建博客 $ hexo new &quot;博客名&quot; 比如： $ hexo new &quot;博客使用方法&quot; 为博客添加标签以及分类 打开/hexo/source/_posts文件夹，找到刚才新建的博客并打开 修改开头内容 title: 博客使用方法date: 2017-02-07 15:18:03tags:categories: 技巧 其中：tags即为文章的标签，可以不写，如果要添加多个标签则使用如下格式： tags:[博客,使用,方法] 每个标签后的逗号必须是英文逗号。 categories即为文章的分类 如果需要手动实现阅读全文功能，则在需要显示阅读全文按钮的地方添加&lt;!--more--&gt;，则文章会从此处截断，显示阅读全文按钮。 如果需要自动设置显示阅读全文功能，在主题文件下的_config.yml里面新增如下代码： 1234# 配置文章字数多于100字后显示阅读全文auto_excerpt: enable: true length: 100 发布博客使用如下命令即可： $ hexo clean 该命令用于清除缓存，可以忽略 $ hexo generate 该命令用户生成静态页面，可以简写为 $ hexo g 如果需要现在本地预览则使用$ hexo server或者可以简写为$ hexo s，然后运行 http://localhost:4000/即可预览。 $ hexo deploy 该命令将本地文件部署到github上，可以简写为$ hexo d]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客搬家]]></title>
      <url>%2F2017%2F01%2F20%2F%E5%8D%9A%E5%AE%A2%E6%90%AC%E5%AE%B6%2F</url>
      <content type="text"><![CDATA[​ 原来一直在CSDN上写博客，不知道是自己不会用还是怎么的，老感觉CSDN的排版很麻烦而且很不人性化。后来被简书的简介唯美风格所吸引，曾经一度想转移到简书，但是感觉简书上太杂乱，什么内容的文章都有，最近才听说有个叫GitHub Pages的神器，于是乎果断尝试，简直是相见恨晚啊。所以，以后的个人博客都将迁移到此处。 ​ 注：原CSDN博客地址：http://blog.csdn.net/zhangym90]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android使用Handler的postDelayed(Runnable, long)方法实现定时任务]]></title>
      <url>%2F2017%2F01%2F17%2FAndroid%E4%BD%BF%E7%94%A8Handler%E7%9A%84postDelayed-Runnable-long-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
      <content type="text"><![CDATA[近期由于公司领导需要将公众号的运营数据放到公司的50寸的微鲸智能电视机上播放，所以一开始是找设计作图，设计问后台要数据，然后做成图片放到电视机上。但是数据是不断更新的，所以设计作图也做的很郁闷。所以我也就顺手做了个app用来展示，顺便解放了设计。当然，功能很简单，就一个界面，背景图是设计原先做的图，然后他将数据扣掉，我在需要添加数据的地方添加几个TextView，然后后台给我一个接口，我这边联网获取数据，每分钟更新一次。 好了，废话说了那么多了，现在主要说说如何实现每分钟更新一次吧，首先创建Handler对象： 1private Handler mHandler = new Handler(); 然后是Runnable，在Runnable的run()方法中调用mHandler.postDelayed(this,60000)，实现每隔1分钟执行一次。 12345678Runnable runnable = new Runnable() &#123; @Override public void run() &#123; showData(); // 循环调用实现定时刷新界面 mHandler.postDelayed(this, 60000); &#125; &#125;; 然后启动定时器即可： 1mHandler.postDelayed(runnable, 1000);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git&GitHub的使用]]></title>
      <url>%2F2016%2F12%2F22%2FGit-GitHub%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[一、 前言1. 简介Git是Linux作者Linus Torvalds开发的一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 2. 特点1) 全球知名公司都在用众所周知，知名的全球最大同性交友平台GitHub只接受git作为唯一版本库格式进行托管。也就说，GitHub上面能见到的开源项目的公司都使用过或者正在使用git，比如国外的Google，Facebook，Square公司，国内的百度，阿里巴巴，360等都在GitHub上有很多开源项目。那么，我们有什么理由不接受它呢？ 2) 因为它真的很好很强大git**与其他版本控制系统的区别：** Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统（CVS，Subversion，Perforce，Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容，请看图 Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。Git 的工作方式类似下图 这是 Git 同其他系统的重要区别。它完全颠覆了传统版本控制的套路，并对各个环节的实现方式作了新的设计。Git 更像是个小型的文件系统，但它同时还提供了许多以此为基础的超强工具，而不只是一个简单的CVS。 在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用 CVS 的话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。 举个例子，如果要浏览项目的历史更新摘要，Git 不用跑到外面的服务器上去取数据回来，而直接从本地数据库读取后展示给你看。所以任何时候你都可以马上翻阅，无需等待。如果想要看当前版本的文件和一个月前的版本之间有何差异，Git 会取出一个月前的快照和当前文件作一次差异运算，而不用请求远程服务器来做这件事，或是把老版本的文件拉到本地来作比较。 3) 使用git更安全在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。这项特性作为Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。 Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起来就像是： Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。 二、 安装git各平台的下载地址：https://git-scm.com/downloads Windows：点击下载的exe文件，一路下一步，几乎不用修改默认配置即可。完成之后再开始菜单下可以看见git的文件夹，里面包含命令行工具跟GUI工具，看个人喜好用哪个。 Linux：Ubuntu下安装使用命令 sudoapt-get install git 安装完成后使用 git –version命令检查是否安装成功。 Mac：mac系统自带，貌似不用安装，检查是否安装方式同Linux。 三、 日常使用1. 创建版本库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 初始化一个Git仓库，使用git init命令。 然后是基本的配置，使用gitconfig –global user.name “zhangym”配置用户名，使用git config –global user.email yongming9011@163.com配置邮件地址。 然后添加文件到Git仓库，分两步： 第一步，使用命令git add ，注意，可反复多次使用，添加多个文件；如果一次修改文件过多，有三个命令可以参考：git add -A 提交所有变化,包括修改的，删除的，新建的文件。 git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)。git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件。如果之前使用了gitadd 命令将文件提交到了缓冲区，但是暂时没有使用git commit命令，然后对文件进行了修改，此时如果需要提交则需要使用git commit -am “提交描述”，如果使用git commit -m “提交描述”会出现fatal: Paths with -a does not make sense.的错误提示。 第二步，使用命令git commit -m “say some words”，完成。简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 l 关于工作区跟暂缓区工作区（Working Directory**）：**创建版本库时新建的那个目录，就是一个工作区。 版本库（Repository**）：**工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 所以，同一个文件，如果已经执行了add命令，然后再修改，再执行commit命令，其实修改是无效的。 2. 管理版本库要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 版本回退Ø 使用回退命令前，用git log可以查看提交历史，以便确定要回退到哪个版本。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数，即git log –pretty=oneline 和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，大家每人都有一个完成的版本库，且每个人手上修改的东西都不一样，如果大家都用1，2，3……作为版本号，你手上的1版本跟我手上的1版本内容肯定不一样，那肯定就冲突了。 Ø Git允许我们在版本的历史之间回退，使用命令gitreset –hard HEAD^ 或者git reset –hard commit_id。Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 Ø 如果后悔回退了，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 其实git内部记录各个操作是通过一种类似游标的方式： 每一次操作相当于把HEAD移动过来移动过去，所以速度特别快。而SVN等其他的则是相当于修改文件，所以效率上比git要差。 3. 管理修改场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，使用git checkout – 命令 命令git checkout – readme.md意思就是，把readme.md文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令。 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时（执行了add命令），想丢弃修改，分两步，第一步用命令git reset HEAD file可以把暂存区的修改撤销掉，重新放回工作区，这样就回到了场景1，第二步按场景1操作。git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。（git reset –hard commit_id）。 4. 删除文件在Git中，删除也是一个修改操作，一般情况下，通常直接在文件管理器中把没用的文件删了，或者用rm命令删了。 使用git status 命令，git会发现工作区跟版本库不同步了 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit，现在，文件就从版本库中被删除了。 另一种情况是删错了，因为缓存区里还有呢，所以可以使用git checkout – test.md很轻松地把误删的文件恢复到最新版本。 git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 5. 远程仓库GitHub将代码托管到GitHub，当然，仅限个人项目，公司项目需慎重（小心公司起诉你）。 1) 从本地仓库关联远程仓库Ø 首先，在https://github.com/注册一个账号，相信大家都会的。 Ø 然后在命令窗口输入： ssh-keygen -t rsa -C”yongming9011@163.com” 然后一路回车，如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSHKey的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人，打开id_rsa.pub.pub，复制里面的内容。 Ø 点击github上账户头像，在弹出的列表中点击Settings，然后在弹出的界面左侧点击SSH and GPG keys 然后在打开的配置界面点击 New SSH key 然后打开添加界面，将刚才复制的信息添加进去，点击Add SSH key生成 在命令行输入ssh -T git@github.com 验证。 Ø 点击头像左侧的➕按钮，选择New repository新建仓库。 Ø 填写完整的信息，然后点击Create repository按钮创建项目。 Ø 创建成功后就会跳转至该项目主界面，点击右侧的Clone or download按钮， 下方显示的就是该项目的远程仓库地址。点击地址后方的按钮，可以复制地址到剪切板。 Ø 在本地仓库使用命令git remote add origin &lt;远程服务地址&gt; 将远程仓库与本地仓库关联。如果要解除与远程的关联，则使用git remote remove &lt;名称&gt; Ø 使用git push -u origin master命令第一次将本地文件提交到远程仓库，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。如果远程仓库有文件使用如上命令会提示错误 此时需要使用命令git pull origin master拉取远程仓库的内容到本地。 如果使用git pull origin master拉取时出现以上问题的话，直接使用 git pull origin master –allow-unrelated-histories命令解决。 Ø 然后就可以愉快的使用github了，此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改。 2) 先有远程仓库，后有本地仓库（常规使用的方式）u github的远程仓库创建方式如上，但是在创建时将下方的一些配置也勾选上，添加过滤文件跟协议。此时创建的仓库会默认自带.gitignore文件，LICENSE,README.md文件。 u 然后在本地新建一个目录，使用git clone xxx(远程仓库地址)命令将远程仓库克隆到本地。这样远程的也就跟本地的关联起来的。 Tips：github支持多种协议，包括https跟ssh等，通常建议使用git原生就支持的ssh协议，主要是速度快，还有个原因就是使用https需要每次都输用户名跟密码，比较麻烦。 6. 分支管理1) 创建与合并分支在版本回退里，已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上 所以，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。 Ø 创建分支：git checkout –b dev创建并切换到dev分支，git checkout命令加上-b参数表示创建并切换，相当于以下两条命令 git branch dev 创建dev分支 git checkout dev 切换到dev分支 然后使用git branch 命令查看当前所有分支，该命令会列出所有分支，当前分支前面会标一个*号 此时我们正处于dev分支上，然后我们修改dev分支的内容并提交，注意，我们的修改跟提交并不影响master分支。 然后再切换到master分支查看mm.txt文件，会看不到刚才添加的内容。因为刚才的内容是在dev分支上提交的。如下图 此时，我们只需要将dev分支合并到master即可，使用命令：git merge dev 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。合并完成后，就可以放心地删除dev分支了,使用git branch –d dev命令删除，或者使用git branch –D dev强制删除。 总结： Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 2) 解决冲突做个实验，我们先在创建个dev分支，然后切换回master分支，修改mm.txt文档，然后commit提交。然后再切换到dev分支，修改mm.txt，完成之后commit。 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。 明显git告诉我们合并失败了，并且告诉我们在mm.txt文件上发生了冲突，并且需要我们去修复冲突，此时去打开仓库的mm.txt，会发现是这样的 其中&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 跟 ======= 之间的内容是当前分支的，=======跟&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间的内容是发生冲突的地方，然后我们需要把这些内容合并处理下并再次add ，commit即可。 使用 git log –graph 可以查看分支合并图。 3) 分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 加上–no-ff参数的git merge表示禁用Fastforward，就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。** 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。然后使用git log –graph 查看合并 如果使用Fast-forword方式可以看出，是没有历史记录的。 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 4) bug分支软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？ 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。 然后使用git status查看会发现工作区是干净的，其实只是我们隐藏了现在，因此可以放心地创建分支来修复bug。 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：假定我们现在需要修复issue-1的bug，我们可以从master上新建一个issue-1分支，然后修复问题，合并分支并删除分支。 现在我们需要恢复工作现场，有两种方式：一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容也删了。 5) Feature分支软件开发中，总有无穷无尽的新的功能要不断添加进来。 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。顺利的话，跟bug分支是类似的，直接合并删除就OK，但是，就在此时，接到上级命令，因经费不足，新功能必须取消！虽然白干了，但是这个分支还是必须就地销毁。 可以看出Git友情提醒，feature分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature。 总结： 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 6) 多人协作当从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用git remote 或者，用git remote -v显示更详细的信息. 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支： 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上。使用命令git push origin master 如果要推送其他分支，则将master改为其他分支名即可。 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支： 多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆, 默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看: 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支. 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程： 然后你在别的机子上也对该文件进行了修改并试图推送，然后你会发现发生了冲突，因为远程仓库的文件已经被你的小伙伴更新了： 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：使用命令git branch –set-upstream-to=origin/dev 然后再pull，会提示有冲突，此时只需要去解决下冲突，然后再push即可，具体做法参考解决冲突章节。 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to=origin/dev 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结： 查看远程库信息，使用gitremote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用gitpush origin branch-name，如果推送失败，先用gitpull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，先切换到需要关联的分支下，然后再使用git branch –set-upstream-to=origin/dev 从远程抓取分支，使用gitpull，如果有冲突，要先处理冲突。 7. 标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。 有人会问，Git有commit，为什么还要引入tag？ “请把上周一的那个版本打包发布，commit号是6a5819e…” “一串乱七八糟的数字不好找！” 如果换一个办法： “请把上周一的那个版本打包发布，版本号是v1.2” “好的，按照tag v1.2查找commit就行！” 所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 1) 创建标签在Git中打标签非常简单，首先，切换到需要打标签的分支上，然后，敲命令git tag 就可以打一个新标签。使用命令git tag 可以查看所有标签 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周三了，但应该在周二打的标签没有打，怎么办？ 方法是找到历史提交的commitid，然后打上就可以了：首先找到commitid 比方说要对add merge这次提交打标签，它对应的commitid是8c105a2，敲入命令：git tag v0.7 8c105a2 即可 使用git tag 查看所有标签，注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show 查看标签信息： 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 还可以通过-s用私钥签名一个标签，具体感兴趣的可以自行Google，百度。 总结： 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； git tag -a -m “……”可以指定标签信息； git tag -s -m “………”可以用PGP签名标签； 命令git tag可以查看所有标签。 2) 操作标签如果标签打错了，也可以删除,使用命令 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin ，或者使用命令git push origin –tags 一次性推送所有尚未推送到远程仓库的标签。 如果标签已经推送到远程，要删除远程标签就麻烦一点，先使用命令git tag -d v0.9 从本地删除，然后使用命令git push origin :refs/tags/v0.9从远程删除。 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。 总结： 命令git push origin 可以推送一个本地标签； 命令git push origin –tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 8. 搭建git服务器git的远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。 GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio常用快捷键]]></title>
      <url>%2F2016%2F12%2F17%2FAndroid-Studio%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"><![CDATA[Android Studio自发布第一版以来已经三年多了，现在已经相当稳定了，并且Google已经停止了对eclipse的支持，so，还在用eclipse的小伙伴们，也是时候换工具了。 本打算写一篇Android Studio的简单使用的教程，由于时间有限，加上本人使用Android Studio时间不是很久，水平有限，故暂时搁置。本文主要记录Android Studio的常用快捷键。 建议大家使用原生的Android Studio的快捷键，而不要修改快捷键为eclipse模式等其他模式，主要是因为Android Studio是基于JetBrains的IntelliJ IDEA开发的，JetBrains旗下有一众非常优秀的IDE，类似大名鼎鼎的IntelliJ IDEA ，PHPStorm，PyCharm，WebStorm等几乎各个领域的开发工具，也就是说你学会了其中一款的快捷键，再上手其他的就很简单了。以下是一些最基本的常用快捷键，需要查看所有的快捷键请去settings --&gt; keymap 里进行查看修改。注意:Mac系统需要将所有的ctrl换成command，alt换成option。 常用快捷键 | Action | Mac OSX | Win/Linux || ——————————- | ———————— | —————————- || 代码提示 | | Shift + 空格 / ctrl + alt + 空格 || 导包,提示错误 | | Alt + enter || 修改变量名（全部） | | Shift + F6 || 复制当前行到下一行 | Command + D | || 调出菜单，setter getter constructor等 | | Ctrl + enter || 调出surround with菜单 | | alt + command + T || 注释代码(//) | Cmd + / | Ctrl + / || 注释代码(/**/) | Cmd + Option + / | Ctrl + Alt + / || 格式化代码 | Cmd + Option + L | Ctrl + Alt + L || 清除无效包引用 | Option + Control + O | Alt + Ctrl + O || 查找 | Cmd + F | Ctrl + F || 查找+替换 | Cmd + R | Ctrl + R || 上下移动代码 | Option + Shift + Up/Down | Alt + Shift + Up/Down || 删除行 | Cmd + Delete | Ctrl + Y || 扩大缩小选中范围 | Option + Up/Down | Ctrl + W/Ctrl + Shift + W || 快捷生成结构体 | Cmd + Option + T | Ctrl + Alt + T || 快捷覆写方法 | Ctrl + O | Ctrl + O || 快捷定位到行首/尾 | Cmd + Left/Right | Ctrl + Left/Right || 折叠展开代码块 | Cmd + Plus,Minus | Ctrl + Plus/Minus || 折叠展开全部代码块 | Cmd + Shift + Plus,Minus | Ctrl + Shift + Plus,Minus || 文件方法结构 | Cmd + F12 | Ctrl + F12 || 查找方法调用的位置 | Ctrl + Option + H | Ctrl + Alt + H || 大小写转换 | Cmd + Shift + U | Ctrl + Shift + U | 调试快捷键 | Action | 快捷键 || ————————————— | ———— || 单步执行,不进入方法；逐过程，相当于下一步 | F8 || 单步执行，进入方法 | F7 || debug时选中查看值 | alt+f8 || 这个是强制进入代码 | alt+shift+f7 || 相当于eclipse的f8跳到下一个断点，也相当于eclipse的f7跳出函数 | shift+f8 || 执行下一轮 | alt + F9 | 如果想要隐藏所有工具栏、工具窗口和编辑器选项卡，请点击 View &gt; Enter Distraction Free Mode。 此操作可启用无干扰模式。 要退出”无干扰模式”，请点击 View &gt; Exit Distraction Free Mode。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android6.0权限的处理]]></title>
      <url>%2F2016%2F12%2F17%2FAndroid6-0%E6%9D%83%E9%99%90%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[关于Android6.0，在申请权限的时有以下需要注意的地方： 若用户勾选了不再提示的选择框之后，是不会再弹出系统的权限申请提示框，这就麻烦了，此时我们需要提示用户去设置里为app开启相应的权限。具体做法：在onRequestPermissionsResult()方法中判断用户拒绝权限后shouldShowRequestPermissionRationale()的值，该值若为false，则表示用户勾选了不再提示，此时，我们可以进行相应的提示。 关于shouldShowRequestPermissionRationale()： 从字面意思可以看出，这个方法是告诉我们是否应该向用户解释我们申请该权限的原因，即告诉用户我们为什么要申请该权限。在app第一次安装的时候。这个方法会返回false，因此你可以直接请求任何需要的权限。如果用户以前拒绝了一个请求，这个方法将返回true，表示你应该向用户解释了。那样的话你应该考虑在再次触发权限对话框之前显示一个解释请求用途之类的信息。此后，如果用户一直点击拒绝，则该值一直为true。 最终，当app完全没有机会被授权的时候，即用户选中了不再显示的复选框之后，shouldShowRequestPermissionRationale()则返回false，这里的意思很明显，用户都已经勾选不再显示了，我们也就不需要再解释了。 然而，我们便可以利用这个方法的返回值进行判断用户是否拒绝并勾选不再显示，当用户拒绝并勾选不再提示后，则我们可以在onRequestPermissionsResult()方法中判断用户拒绝权限后该值是否为false，如果为false，那么表示用户拒绝了权限并勾选不再显示。 123456789@Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (grantResults[0] == PackageManager.PERMISSION_DENIED)&#123; if (ActivityCompat.shouldShowRequestPermissionRationale(this,permissions[0]))&#123; // 用户拒绝，并勾选了 不再显示 &#125; &#125; &#125; 建议使用GitHub上严振杰大神封装好的库AndPermission，还是比较方便的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RxJava学习笔记]]></title>
      <url>%2F2016%2F12%2F14%2FRxJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[RxJava的常用操作符 just(T...):将传入的参数依次发送出来,快捷创建创建事件队列的方法 1Observable.just("hello","world”); 等同于 12345678Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("hello"); subscriber.onNext("world"); subscriber.onCompleted(); &#125; &#125;) from(T[]) / from(Iterable) : 将传入的数组或 Iterable 拆分成具体对象后，依次发送出 12String[] words = new String[]&#123;"hello","world"&#125;; Observable.from(words); 等同于 123456789Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("hello"); subscriber.onNext("world"); subscriber.onCompleted(); &#125; &#125;) Rxjava的知识点RxJava的基本实现方式： Observable即被观察者，它决定了什么时候触发事件以及触发怎样的事件。 Observer即观察者，它决定了事件触发的时候将有怎样的行为。 123456789101112131415161718192021222324Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("hello"); subscriber.onNext("world"); subscriber.onCompleted(); &#125; &#125;) .subscribe(new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.d(TAG,"onCompleted") &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onNext(String s) &#123; Log.d(TAG,s); &#125; &#125;); 除了Observer接口之外，RxJava还内置了一个实现了Observer的抽象类：Subscriber. 123456789101112131415161718192021222324Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("hello"); subscriber.onNext("world"); subscriber.onCompleted(); &#125; &#125;) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.d(TAG, "onCompleted"); &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onNext(String s) &#123; Log.d(TAG, s); &#125; &#125;); 两种使用方式是一样的。它们的区别对于使用者来说主要有两点： Subscriber新增加了onStart()方法，它会在subscribe刚开始事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或者重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作有线程要求（如弹出一个转菊花的ProgressBar,就必须在主线程执行），onStart()方法就不适用了，因为它总是在subscribe所发生的线程被调用，而不能指定线程。需要在指定线程来做准备工作，可以使用doOnSubscribe()方法。 Subscriber实现了另一个方法unsubscribe(),这个方法被调用后，Subscriber将不再接收事件。一般这个方法调用前，可以使用isUnsubscribed()先判断一下状态。unsubscribe()主要用于解除引用关系，以避免内存泄露的发生。 Action 1234567891011121314151617181920212223242526272829Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; // next() Log.d(TAG,s); &#125; &#125;; Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; // ERROR &#125; &#125;; Action0 onCompletedAction = new Action0() &#123; @Override public void call() &#123; // complete Log.d(TAG,"onCompleted"); &#125; &#125;; // 自动创建Subscriber,并使用onNextAction来定义onNext()； observable.subscribe(onNextAction); // 自动创建Subscriber,并使用onNextAction onErrorAction 来定义onNext() onError() observable.subscribe(onNextAction,onErrorAction); // 自动创建Subscriber,并使用onNextAction onErrorAction onCompletedAction来定义onNext() onError() onCompleted() observable.subscribe(onNextAction,onErrorAction,onCompletedAction); Action0是RxJava的一个接口，它只有一个方法call(),这个方法是无参数无返回值的；由于onCompleted()方法也是无参数无返回值得，因此Action0可以被当成一个包装对象，将onCompleted()的内容打包起来将自己作为一个参数传入subscribe()以实现不完整定义的回调。Action1也是一个接口，它同样只有一个方法call(T t)，这个方法也无返回值，但是有一个参数；与Action0同理，由于onNext(T t)和onError(Throwable error)也是单参数无返回值的，因此Action1可以将onNext(t)和onError(error)打包。 RxJava提供了多个ActionX形式的接口，他们可以用以包装不同的无返回值的方法。ActionX的方法是无返回值的。 例如，将字符串数组names中的所有字符串依次打印出来： 12345678String[] names = new String[]&#123;"John","Jim","Tom","Alexander"&#125;; Observable.from(names) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d(TAG,s); &#125; &#125;); 线程控制 —— Scheduler 在不指定线程的情况下，RxJava遵循的是线程不变的原则，即：在哪个线程调用subscribe()，就在哪个线程产生事件；在哪个线程产生事件就在哪个线程消费事件。如果需要切换线程，就需要用到Scheduler（调度器）。RxJava通过它来指定每一段代码应该运行在什么样的线程。RxJava已经内置了几个Scheduler: Schedulers.immediate():直接在当前线程中运行，相当于不指定线程。这是默认的Scheduler。 Schedulers.newThread():总是启用新线程，并在新线程执行操作。 Schedulers.io():I/O操作（读写文件，读写数据库，联网等）所使用的Scheduler。行为模式跟newThread()的差不多，区别在于io()的内部实现是一个无数量上线的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。不要把计算工作放在io()中，可以避免创建不必要的线程。 Schedulers.computation()：计算所使用的Scheduler。这个计算指的是cpu密集型计算，即不会被I/O等操作限制性能的操作，例如图形的计算。这个Scheduler使用的是固定的线程池，大小为CPU核心数。不要把I/O操作放在computation()中，否则I/O操作的等待时间会浪费cpu。 另外，Android还有一个专用的AndroidSchedulers.mainThread()，它制定的操作将在Android主线程运行。 有了这几个Scheduler，就可以使用subscribeOn()和observeOn()两个方法来对线程进行控制。subscribeOn()指定subscribe()所发生的线程，即Observable.OnSubscribe被激活时所处的线程，或者叫做事件产生的线程。observeOn()指定Subscriber所运行在的线程。或者叫做事件的消费的线程。 123456789101112String[] names = new String[]&#123;"John","Jim","Tom","Alexander"&#125;; Observable.from(names) // 指定names发生的线程在io()线程，被创建的事件的内容names会在io线程发出 .subscribeOn(Schedulers.io()) // 指定Subscriber的回调发生在主线程，故打印将发生在主线程。 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d(TAG,s); &#125; &#125;); 事实上，这种在subscribe()之前写上两句subscribeOn(Scheduler.io())和observeOn(AndroidSchedulers.mainThread())的使用方式非常常见，它适用于多数的“后台线程取数据，主线程显示”的程序策略。 变换 所谓变化，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。 observeOn()指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次observeOn()即可。不过，不同于observeOn(),subscribeOn()的位置放在哪里都可以，但它是只能调用一次的。当使用了多个subscribeOn()的时候，只有第一个subscribeOn()起作用。 然而，虽然超过一个的subscribeOn()对事件处理的流程没有影响，但在流程之前确是可以利用的。那就是与Subscriber.onStart()方法相对应的Observable.doOnSubscribe()方法，它和Subscriber.onStart()同样是在subscribe()调用后且在事件发送前执行，但区别在于它可以指定线程。默认情况下，doOnSubscribe()执行在subscribe()发生的线程。如果在doOnSubscribe()之后有subscribeOn()方法，则它将执行离他最近的subScribeOn()所指定的线程。如下，在doOnSubscribe()后面跟一个subscribeOn()，就能指定准备工作的线程了。 123456789101112131415161718Observable.just("hello","world") .subscribeOn(Schedulers.io()) .doOnSubscribe(new Action0() &#123; @Override public void call() &#123; // 需要在主线程执行 showProgressBar(); &#125; &#125;) // 指定主线程 .subscribeOn(AndroidSchedulers.mainThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d(TAG,s); &#125; &#125;); Func 123456789101112131415Observable.just("images/sky.png") .map(new Func1&lt;String, Bitmap&gt;() &#123; @Override public Bitmap call(String s) &#123; return getBitmapFromFile(s); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; iv.setImageBitmap(bitmap); &#125; &#125;); 这里出现了一个叫做Func1的类。它和Action1非常相似，也是RxJava的一个接口，用于包装含有一个参数的方法。Func跟Action的区别在于，Func包装的是有返回值的方法。另外，和ActionX一样，FuncX也有多个，用于不同参数个数的方法。 map():事件对象的直接变换。它是RxJava最常用的变换。 flatMap():它也是把传入的参数转化之后返回另一个对象。但是跟map()不同的是，flatMap()返回的是个Observable对象，并且这个Observable对象并不是被直接发送到了Subscriber的回调方法中。 throttleFirst()：在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听事件。 ———————————♥︎举个栗子♥︎———————————— 假如我现在需要联网加载百度的页面，然后将返回的内容显示在一个TextView上，就可以这么写： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class MainActivity extends AppCompatActivity &#123; private TextView tvFirst; private TextView tvResult; private ProgressDialog dialog; private static final String TAG = "zhangym"; private Observable&lt;String&gt; mObservable; private Subscriber&lt;String&gt; mSubscriber; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvFirst = (TextView) findViewById(R.id.tv_fist); tvResult = (TextView) findViewById(R.id.tv_result); tvFirst.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; showResponseResult(); &#125; &#125;); &#125; private void showResponseResult() &#123; // 创建被观察者 mObservable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; HttpURLConnection connection = null; try &#123; URL url = new URL("https://www.baidu.com/"); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("GET"); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); InputStream is = connection.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); StringBuilder sb = new StringBuilder(); String line = null; while ((line = reader.readLine()) != null) &#123; sb.append(line); &#125; // 发送事件 subscriber.onNext(sb.toString()); subscriber.onCompleted(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); // 创建观察者 mSubscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.d(TAG, "onCompleted"); dialog.dismiss(); &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onNext(String s) &#123; tvResult.setText(s); &#125; &#125;; // 指定联网操作在io线程 mObservable.subscribeOn(Schedulers.io()) // 事件发送前的准备工作 .doOnSubscribe(new Action0() &#123; @Override public void call() &#123; dialog = new ProgressDialog(MainActivity.this, ProgressDialog.THEME_DEVICE_DEFAULT_LIGHT); dialog.setProgressStyle(ProgressDialog.STYLE_SPINNER); dialog.setIndeterminate(true); dialog.show(); &#125; &#125;) // 指定doOnSubscribe()的线程为UI线程 .subscribeOn(AndroidSchedulers.mainThread()) // 指定Subscriber的线程为UI线程，即在UI线程显示结果 .observeOn(AndroidSchedulers.mainThread()) // 订阅事件 .subscribe(mSubscriber); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // 取消订阅，防止内存泄露 if (!mSubscriber.isUnsubscribed())&#123; mSubscriber.unsubscribe(); &#125; &#125; &#125; 运行效果: 由于网速较快，所以ProgressDialog一闪而过，gif图上面看不出来。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java中回调的理解]]></title>
      <url>%2F2016%2F12%2F12%2FJava%E4%B8%AD%E5%9B%9E%E8%B0%83%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[回调在Java中运用的相当广泛，类似Android中的控件点击监听事件setOnClickListener()方法就是典型的回调。回调是什么？关于回调的定义通俗地说就是：A类调用B类中的某个方法，然后B类中反过来调用A类中的方法D,D这个方法就叫做回调方法。在Java中回调的这个方法D一般是接口中定义，然后A类通过实现接口的D方法。 一般回调的话需要满足以下几个条件： Class A实现接口CallBack callback ——场景1 class A中包含一个class B的引用b ——场景2 class B有一个参数为callback的方法f(CallBack callback) ——场景3 A里的B的引用调用B的方法 f(CallBack callback) ——A类调用B类的某个方法C ——场景4 然后b就可以在f(CallBack callback)方法中调用A的方法 ——B类调用A类的某个方法D ——场景5 接下来我将通过一个demo说明，假设我需要实现一个类似下载完成的监听方法。具体就是Download这个类可以实现下载，给它的构造方法中传入我们需要下载的数据量，其开始下载，并且提供了下载完成的监听，当下载成功或者失败后调用对应的回调方法。 首先，定义一个下载完成的接口，接口中包含了下载完成后的两个回调方法。 123456789101112131415/** * 下载完成的回调接口 * Created by zhangyongming on 2016/12/12. */ public interface OnDownloadCompleted &#123; /** * 下载成功的回调 */ void onSuccess(); /** * 下载失败的回调 */ void onFail(); &#125; 然后是Download类：Download类有一个setOnDownloadCompletedListener(OnDownloadCompleted onDownloadCompleted)方法（相当于场景3），在该方法中模拟了下载过程，并且根据下载的结果调用了Test类的onSucess()跟onFail()方法（相当于场景5，这两个方法是Test类实现了OnDownloadCompleted接口后实现的方法），在这里我们模拟如果下载结果为100则为下载成功，否则下载失败。 123456789101112131415161718192021222324252627282930/** * 模拟下载的类，里面有一个设置下载完成的监听 * Created by zhangyongming on 2016/12/12. */ public class Download &#123; private int progress; public Download(int progress) &#123; this.progress = progress; &#125; // class B有一个参数为callback的方法f(CallBack callback) ——场景3 public void setOnDownloadCompletedListener(OnDownloadCompleted onDownloadCompleted) &#123; for (int i = 0; i &lt;= progress; i++) &#123; System.out.println("下载进度： " + i + "%"); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 然后b就可以在f(CallBack callback)方法中调用A的方法 ——B类调用A类的某个方法D ——场景5 if (progress == 100) &#123; onDownloadCompleted.onSuccess(); &#125; else &#123; onDownloadCompleted.onFail(); &#125; &#125; &#125; 然后是Test类方法：Test类实现了OnDownloadCompleted接口，实现了onSuccess()方法跟onFail()方法（场景1）；Test类包含了Download类的引用（场景2），Download的实例调用了setOnDownloadCompletedListener()方法（场景4）。 12345678910111213141516171819202122232425262728293031323334/** * Class A实现接口CallBack callback ——场景1 * Created by zhangyongming on 2016/12/12. */ public class Test implements OnDownloadCompleted &#123; public static void main(String[] args) &#123; // class A中包含一个class B的引用b ——场景2 Download download = new Download(20); // A里的B的引用调用B的方法 f(CallBack callback) ——A类调用B类的某个方法C ——场景4 download.setOnDownloadCompletedListener(new Test()); &#125; @Override public void onSuccess() &#123; System.out.println("┏━━━━━┳━━━━━┓"); System.out.println("┃ ┃ ┃"); System.out.println("┃ ┃"); System.out.println("┣━ 下载完成 ━┫"); System.out.println("┃ ┃"); System.out.println("┃ ┃ ┃"); System.out.println("┗━━━━━┻━━━━━┛"); &#125; @Override public void onFail() &#123; System.out.println("┏ ━ ━ ┳ ━ ━ ┓"); System.out.println(" "); System.out.println("┃ ┃"); System.out.println(" 下载失败 "); System.out.println("┃ ┃"); System.out.println(" "); System.out.println("┗ ━ ━ ┻ ━ ━ ┛"); &#125; &#125; 上述demo我们输入一个int值之后，变开始进行循环，模拟下载过程，然后根据下载结果调用相应的方法展示数据。输出结果如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio添加日志过滤]]></title>
      <url>%2F2016%2F12%2F07%2FAndroid-Studio%E6%B7%BB%E5%8A%A0%E6%97%A5%E5%BF%97%E8%BF%87%E6%BB%A4%2F</url>
      <content type="text"><![CDATA[点击下方的 Android Monitor 点击右侧的选项菜单 点击菜单下拉列表中的 Edit Filter Configuration，打开配置界面 配置界面说明 第1部分是为这个过滤器输入名称，第2部分是一些过滤信息的配置：Log Tag 是根据log.d(&quot;XXX&quot;,&quot;show&quot;);方法中的XXX参数属性过滤，配置该项之后只会显示日志中Tag为XXX的日志;Log Message是根据日志信息过滤；Package Name是根据包名过滤；Log Level是配置显示日志的级别，一般看自己需求配置；配置完成之后点击OK确认。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac使用Dryrun做到不用运行Android Studio即可在模拟器安装预览GitHub开源项目]]></title>
      <url>%2F2016%2F12%2F06%2Fmac%E4%BD%BF%E7%94%A8Dryrun%E5%81%9A%E5%88%B0%E4%B8%8D%E7%94%A8%E8%BF%90%E8%A1%8CAndroid-Studio%E5%8D%B3%E5%8F%AF%E5%9C%A8%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AE%89%E8%A3%85%E9%A2%84%E8%A7%88GitHub%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[Dryrun是GitHub上的一个开源工具，它最强大的地方在于可以只用一行命令行即可让你运行GitHub上的项目，是不是很激动？ 通常我们需要预览GitHub上的开源项目一般会做以下几步： 找到这个项目 点击项目右侧的 Clone or download下载整个项目资源 解压缩下载下来的zip文件 导入Android Studio 同步gradle配置 如果缺少配置文件或者项目报错，则需要先排错 运行项目并预览 如果正巧是自己希望的效果，留下，如果不是，删除。 然而Dryrun只需要一行命令即可，剩下的我们都不用操心，只需安静等待即可。。。。 下面来说说如何在mac上配置吧。 首先安装前需要配置ANDROID_HOME环境变量，方法如下： 启动Terminal终端工具 输入cd ~/ 进入当前用户的home目录 或cd /Users/YourUserName 如果不存在则创建： touch .bash_profile 如果存在,就打开并编辑：open .bash_profile 在里面添加sdk的tools和platform-tools的路径,注意每个路径要用 : 隔开,并且这个路径换成你自己的刚才解压后的sdk的实际路径. 1export PATH=$PATH:/Users/youname/android/soft/adt-bundle-mac-x8664-20130522/sdk/platform-tools:/Users/youname/android/soft/adt-bundle-mac-x8664-20130522/sdk/tools(具体的文件名你自己对应) 保存关闭 更新： source .bash_profile ok了,在Terminal终端工具里输入adb -version看看,是否出来类似的界面: Android Debug Bridge version 1.0.31 如果出来了,说明已经成功了. 然后安装Dryrun，使用如下命令 $ sudo gem install dryrun 顺利的话应该就安装成功了，如果报错一般会有类似ERROR: Failed to build gem native extension. 这种错误，经过各种查资料折腾，基本上确定这个错误的一般是ruby的相关依赖文件未安装完全（网上查的，如有错误还望指正）。一般情况安装xcode后貌似就能解决，如果还是不行请自行Google或百度。安装完成后便可使用，使用方法为dryrun + 项目地址，如：dryrun https://github.com/cesarferreira/android-helloworld，接下来就是见证奇迹的时候了（图是借用dryrun官方的效果图）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Text中的属性设置]]></title>
      <url>%2F2016%2F10%2F28%2FSublime-Text%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[12345678&#123; "font_face": "Courier New", "font_size": 14.0, "update_check": false, "open_files_in_new_window": false, "hot_exit": false, "remember_open_files": false &#125; 这些配置是需要放在Preference--&gt;settings-User下的，其中 font_face 是设置字体类型的，font_size 是设置字体大小的，update_check 表示是否开启检查更新， open_files_in_new_window表示是否在新窗口中打开文件，remember_open_files 表示是否记住上次打开的文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于toolbar菜单设置了always后不显示的问题]]></title>
      <url>%2F2016%2F10%2F27%2F%E5%85%B3%E4%BA%8Etoolbar%E8%8F%9C%E5%8D%95%E8%AE%BE%E7%BD%AE%E4%BA%86always%E5%90%8E%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[我们一般写menu文件时会有如下写法： 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:id="@+id/menu011" android:title="hehe" android:icon="@mipmap/ic_launcher" android:showAsAction="always"/&gt; &lt;/menu&gt; 这样写出来的menu是不会再toolbar上面显示的，跟设置的never一样都在隐藏菜单里。解决这个问题的办法其实很简单，如下： 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;item android:id="@+id/menu_home" android:icon="@mipmap/home" app:showAsAction="always" android:title="@string/menu_home"/&gt; &lt;/menu&gt; 新增一句 1xmlns:app="http://schemas.android.com/apk/res-auto" 将 1android:showAsAction="always" 改成 1app:showAsAction="always" 即可解决。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[友盟统计sdk集成及多渠道打包]]></title>
      <url>%2F2016%2F10%2F13%2F%E5%8F%8B%E7%9B%9F%E7%BB%9F%E8%AE%A1sdk%E9%9B%86%E6%88%90%E5%8F%8A%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%2F</url>
      <content type="text"><![CDATA[友盟统计sdk集成其实很简单，先去友盟官网新建应用，然后会得到一个Appkey。 然后根据友盟的sdk集成文档在Android Studio的app目录下的build.gradle添加如下代码，集成友盟统计sdk： 12// 友盟统计的sdk compile 'com.umeng.analytics:analytics:latest.integration' 然后在AndroidManifest.xml的Application标签下配置 1234567&lt;!-- 友盟appid --&gt; &lt;meta-data android:name="UMENG_APPKEY" android:value="XXX"&gt; &lt;/meta-data&gt; &lt;!--此处配置是为了方便酷传多渠道打包 --&gt; &lt;meta-data android:value="" android:name="UMENG_CHANNEL"/&gt; 其中XXX为你自己的Appkey，UMENG_CHANNEL的值为空字符串主要是为了使用酷传的多渠道打包。然后找到程序的入口Activity，即AndroidManifest.xml里配置了如下代码的Activity 1234567&lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 在该Activity的onResum()跟onPause()方法里添加如下代码 1234567891011@Override protected void onResume() &#123; super.onResume(); MobclickAgent.onResume(this); &#125; @Override protected void onPause() &#123; super.onPause(); MobclickAgent.onPause(this); &#125; 至此，友盟统计的基本功能已经集成完毕。然后就是使用酷传进行多渠道打包了，先在酷传官网下载酷传的软件，然后申请账号，打开软件并登录 选择 上方的 工具箱 ，打开如下界面 选择 生成多渠道包，然后选择需要多渠道打包的apk文件 点击下一步，在弹出的渠道包签名对话框中选择相应的release版的keystore文件，并填写相应的信息 然后点击生成渠道包，就会出现生成渠道包的界面，完成后会在原始的apk文件所在的目录生成一个叫做 酷传智能分包 的文件夹，里面就是生成的多渠道包。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记录友盟分享，第三方登录遇到的坑]]></title>
      <url>%2F2016%2F08%2F26%2F%E8%AE%B0%E5%BD%95%E5%8F%8B%E7%9B%9F%E5%88%86%E4%BA%AB%EF%BC%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
      <content type="text"><![CDATA[最近公司项目上需要用到分享跟第三方登录，由于友盟集成的社会化分享在国内的口碑还挺不错的，所以就集成进项目了，经历了各种坑之后，基本上算是告一段落了，现在把遇到的各种坑记录下来，希望能帮到一些遇到相同问题的猿友。 坑1：QQ第三方登录的坑 QQ第三方登录需要你在腾讯开放平台申请一个AppID及Appkey ，然后才能使用，由于同一个app使用不同的签名文件生成的AppID及Appkey是不一样的，如果你给腾讯那边上传的是一个debug版的apk，那么这个AppID及Appkey就是debug版的，然后你的第三方登录只有在使用dubug版的时候才能用，在正式包下会提示错误：应用不是最新的（100044）这个错误，所以这一点一定要注意，如果你给腾讯上传的是一个release版的apk，那么你以后的每次调试QQ登录都得用release的签名打包，我的做法是，调试的时候直接用release版的签名编译，具体参考：这篇文章的做法 。 QQ的第二个坑，QQ的接口返回的唯一码是一个叫openId的东东，其实我一直不明白它为什么不返回一个QQ号啊，因为这个东西不管在哪个平台都是唯一的，算了，不扯这些了，既然人家不给返回QQ号码自然有人家的想法，也许是为了用户隐私之类的。现在就说说这个openId，据我的理解，应该是与应用的appId还有应用的签名有关（个人理解，如有错误还望指正），所以不同的应用返回的openId是不一样的，在这里我就遇到坑了，因为我们公司iOS开发的比Android早半年，所以当初ios自己用自己的账号申请了一个ios的AppID及Appkey，现在Android这边我用公司的账号在应用宝上架的app，所以同一个QQ账号的第三方登录在ios跟Android返回的openId都不一样，经过咨询腾讯客服（QQ：800013811），告诉我只有一个办法解决，那就是把一方的应用转让给另一方，保证ios的跟Android的都在一个开发者账号下，然后再申请数据互通。。。。只有这样，才能保证相同的QQ号在两个平台的openId才能一致。 坑2：新浪微博的坑 新浪这个就比较坑了，由于我用的是Android Studio，我直接将新浪的sdk里的libs下的那些so文件夹直接拷贝到我的libs里面，原以为这样就好了（貌似在ADT下确实就好了），结果运行各种闪退，日志也没啥特殊的地方，死活不知道原因，最后纠结了两天，想着可能是so文件的原因，就百度了下Android Studio如何导入so文件，按照操作执行了之后，瞬间就好了，简直汗颜。关于在Android Studio下如何导入so文件请参考：这篇文章 或者 这篇文章。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何去掉Android Studio的注释警告]]></title>
      <url>%2F2016%2F08%2F11%2F%E5%A6%82%E4%BD%95%E5%8E%BB%E6%8E%89Android-Studio%E7%9A%84%E6%B3%A8%E9%87%8A%E8%AD%A6%E5%91%8A%2F</url>
      <content type="text"><![CDATA[我们知道，使用Android Studio（以下简称AS）如果给一个方法添加文档注释时，方法里的参数也必须添加注释，否则会有警告。如下： 其实给参数添加注释是个很好的习惯，但是如果是重写的或者实现接口的抽象方法，有时候我们不需要给参数加注释，然而AS会报警告，右侧会有黄色的横条，这些警告跟代码警告混在一起，很影响阅读，所以有时候我们需要去掉。 具体步骤：File-&gt;Settings-&gt;Editor-&gt;Inspections,在右侧找到Javadoc issues下的Declaration has Javadoc problems右侧的勾去掉然后点击Apply或者OK即可。 然后就可以看到效果了。]]></content>
    </entry>

    
  
  
</search>
