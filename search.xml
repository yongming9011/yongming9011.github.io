<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android获取发布版签名文件的指纹]]></title>
      <url>%2F2017%2F02%2F09%2FAndroid%E8%8E%B7%E5%8F%96%E5%8F%91%E5%B8%83%E7%89%88%E7%AD%BE%E5%90%8D%E6%96%87%E4%BB%B6%E7%9A%84%E6%8C%87%E7%BA%B9%2F</url>
      <content type="text"><![CDATA[有时候申请一些第三方sdk时，比如百度地图的sdk，需要获取正式版签名文件的指纹，关于如何获取，在命令窗口输入以下命令即可： 1$ keytool -list -v -keystore /Users/zhangyongming/Desktop/Project/ezhenduankey.jks 即keytool -list -v -keystore &lt;文件路径&gt;即可，然后复制签名信息里的SHA1的值就行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客使用方法]]></title>
      <url>%2F2017%2F02%2F07%2F%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[新建博客$ hexo new 博客名 比如，新建一个名为“博客使用方法”的博客： $ hexo new 博客使用方法 为博客添加标签以及分类 打开/hexo/source/_posts文件夹，找到刚才新建的博客并打开 修改开头内容 title: 博客使用方法date: 2017-02-07 15:18:03tags:categories: 技巧 其中：tags即为文章的标签，可以不写，如果要添加多个标签则使用如下格式： tags:[博客,使用,方法] 每个标签后的逗号必须是英文逗号“,”，categories即为文章的分类。 发布博客发布博客使用如下命令即可： $ hexo clean 该命令用于清除pulic文件夹缓存，可以忽略 $ hexo generate 该命令用户生成静态页面，可以简写为 $ hexo g 如果需要现在本地预览则使用$ hexo server或者可以简写为$ hexo s，然后运行 http://localhost:4000/即可预览。 $ hexo deploy 该命令将本地文件部署到github上，可以简写为$ hexo d 如果需要文章禁止评论，则在页面的 Front-matter 里添加comments 字段，并将值设置为 false。如下所示： title: tagsdate: 2017-02-06 13:37:19type: tagscomments: false 设置阅读全文 手动设置 如果需要手动实现阅读全文功能，则在需要显示阅读全文按钮的地方添加&lt;!--more--&gt;，则文章会从此处截断，显示阅读全文按钮。 自动形成摘要 在主题文件下的_config.yml里面新增如下代码： 1234# 配置文章字数多于100字后显示阅读全文auto_excerpt: enable: true length: 100 ​ 参考链接： NextT相关设置 Hexo的相关设置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客搬家]]></title>
      <url>%2F2017%2F01%2F20%2F%E5%8D%9A%E5%AE%A2%E6%90%AC%E5%AE%B6%2F</url>
      <content type="text"><![CDATA[​ 原来一直在CSDN上写博客，不知道是自己不会用还是怎么的，老感觉CSDN的排版很麻烦而且很不人性化。后来被简书的简洁唯美风格所吸引，曾经一度想转移到简书，但是感觉简书上太杂乱，什么内容的文章都有，最近才听说有个叫GitHub Pages的神器，于是乎果断尝试，简直是相见恨晚啊。所以，以后的个人博客都将迁移到此处。 ​ 注：原CSDN博客地址：http://blog.csdn.net/zhangym90]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android使用Handler的postDelayed(Runnable, long)方法实现定时任务]]></title>
      <url>%2F2017%2F01%2F17%2FAndroid%E4%BD%BF%E7%94%A8Handler%E7%9A%84postDelayed-Runnable-long-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
      <content type="text"><![CDATA[近期由于公司领导需要将公众号的运营数据放到公司的50寸的微鲸智能电视机上播放，所以一开始是找设计作图，设计问后台要数据，然后做成图片放到电视机上。但是数据是不断更新的，所以设计作图也做的很郁闷。所以我也就顺手做了个app用来展示，顺便解放了设计。当然，功能很简单，就一个界面，背景图是设计原先做的图，然后他将数据扣掉，我在需要添加数据的地方添加几个TextView，然后后台给我一个接口，我这边联网获取数据，每分钟更新一次。 好了，废话说了那么多了，现在主要说说如何实现每分钟更新一次吧，首先创建Handler对象： 1private Handler mHandler = new Handler(); 然后是Runnable，在Runnable的run()方法中调用mHandler.postDelayed(this,60000)，实现每隔1分钟执行一次。 12345678Runnable runnable = new Runnable() &#123; @Override public void run() &#123; showData(); // 循环调用实现定时刷新界面 mHandler.postDelayed(this, 60000); &#125; &#125;; 然后启动定时器即可： 1mHandler.postDelayed(runnable, 1000);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[属性动画Property Animation的扩展用法]]></title>
      <url>%2F2017%2F01%2F10%2F%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BBProperty-Animation%E7%9A%84%E6%89%A9%E5%B1%95%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Interpolator的使用Interpolator字面意思就是插入器（有道翻译），在动画中，它的主要作用是改变动画的执行速率，比如匀速，加速等一系列效果。Interpolator可以自定义实现，以下是Android系统已经为我们写好了的一些插入器： AccelerateDecelerateInterpolator —— 在动画开始与结束的地方速率改变比较慢，在中间的时候加速 AccelerateInterpolator ——————– 在动画开始的地方速率改变比较慢，然后开始加速 AnticipateInterpolator ——————— 开始的时候向后然后向前甩 AnticipateOvershootInterpolator ——– 开始的时候向后然后向前甩一定值后返回最后的值 BounceInterpolator ———————— 动画结束的时候弹起，类似皮球掉地上弹起的效果 CycleInterpolator ————————— 动画循环播放特定的次数，速率改变沿着正弦曲线 DecelerateInterpolator ——————— 在动画开始的地方快然后慢 LinearInterpolator ————————- 以常量速率改变，即匀速 OvershootInterpolator ——————- 向前甩一定值后再回到原来位置 具体的使用比较简单，在Java代码中调用动画对象的setInterpolator()方法传入Interpolator对象： 123456ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(mImageView, "translationY", mImageView.getTranslationY(), 400); // 设置动画时长 objectAnimator.setDuration(5000); // 设置弹起效果 objectAnimator.setInterpolator(new BounceInterpolator()); objectAnimator.start(); 在xml中使用android:interpolator 属性： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!-- 将alpha的值从1过渡到0，时长1秒 --&gt; &lt;objectAnimator xmlns:android="http://schemas.android.com/apk/res/android" android:valueFrom="1" android:valueTo="0" android:valueType="floatType" android:duration="1000" android:propertyName="alpha" android:interpolator="@android:anim/linear_interpolator"/&gt; TypeEvaluator的用法TypeEvaluator翻译为类型估值算法，又称估值器，它的作用是通过起始值、结束值以及插值器返回值来计算在该时间点的属性值应该是多少，也就是控制动画实际运动轨迹，系统给我们提供IntEvaluator（针对整型属性）、FloatEvaluator（针对浮点型属性）以及ArgbEvaluator（针对Color属性），如果想根据某个属性TYPE来实现动画，但是这个Type又不是Android系统内置的，这个时候就需要创建一个自己的evaluator来实现了，并且新创建的type必须实现接口TypeEvaluator。Android系统内置的type有int,float和color，他们对应的evaluator是IntEvaluator、FloatEvaluator和ArgbEvaluator。接口TypeEvaluator内只有一个方法，用来计算要实现动画属性的值。以下是TypeEvaluator接口： 123456789101112131415161718192021222324252627/** * Interface for use with the &#123;@link ValueAnimator#setEvaluator(TypeEvaluator)&#125; function. Evaluators * allow developers to create animations on arbitrary property types, by allowing them to supply * custom evaluators for types that are not automatically understood and used by the animation * system. * * @see ValueAnimator#setEvaluator(TypeEvaluator) */ public interface TypeEvaluator&lt;T&gt; &#123; /** * This function returns the result of linearly interpolating the start and end values, with * &lt;code&gt;fraction&lt;/code&gt; representing the proportion between the start and end values. The * calculation is a simple parametric calculation: &lt;code&gt;result = x0 + t * (x1 - x0)&lt;/code&gt;, * where &lt;code&gt;x0&lt;/code&gt; is &lt;code&gt;startValue&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt; is &lt;code&gt;endValue&lt;/code&gt;, * and &lt;code&gt;t&lt;/code&gt; is &lt;code&gt;fraction&lt;/code&gt;. * * @param fraction The fraction from the starting to the ending values * @param startValue The start value. * @param endValue The end value. * @return A linear interpolation between the start and end values, given the * &lt;code&gt;fraction&lt;/code&gt; parameter. */ public T evaluate(float fraction, T startValue, T endValue); &#125; 接口只有一个方法evaluate()返回了一个泛型，方法的第一个参数是估值小数，也就是插值器计算出来的当前属性改变的百分比，第二个参数是动画开始值，第三个参数是动画的结束值。 我们看看IntEvaluator的实现： 123456789101112131415161718192021222324/** * This evaluator can be used to perform type interpolation between &lt;code&gt;int&lt;/code&gt; values. */ public class IntEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; /** * This function returns the result of linearly interpolating the start and end values, with * &lt;code&gt;fraction&lt;/code&gt; representing the proportion between the start and end values. The * calculation is a simple parametric calculation: &lt;code&gt;result = x0 + t * (v1 - v0)&lt;/code&gt;, * where &lt;code&gt;x0&lt;/code&gt; is &lt;code&gt;startValue&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt; is &lt;code&gt;endValue&lt;/code&gt;, * and &lt;code&gt;t&lt;/code&gt; is &lt;code&gt;fraction&lt;/code&gt;. * * @param fraction The fraction from the starting to the ending values * @param startValue The start value; should be of type &lt;code&gt;int&lt;/code&gt; or * &lt;code&gt;Integer&lt;/code&gt; * @param endValue The end value; should be of type &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;Integer&lt;/code&gt; * @return A linear interpolation between the start and end values, given the * &lt;code&gt;fraction&lt;/code&gt; parameter. */ public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(startInt + fraction * (endValue - startInt)); &#125; &#125; 很明显，其在evaluate()方法中进行了数值的转换，并返回了结果，所以我们只需照着做就行。 比如，我现在需要让一个图片实现抛物线运动，则可以借助自定义的TypeEvaluator实现，首先定义一个坐标类Point，里面包含x轴跟y轴，以及对应的setter,getter 123456789101112131415161718192021222324252627282930/** * 坐标点，用于控制动画的位置 * Created by zhangyongming on 2017/1/11. */ public class Point &#123; private float x; private float y; public Point(float x, float y) &#123; this.x = x; this.y = y; &#125; public float getX() &#123; return x; &#125; public void setX(float x) &#123; this.x = x; &#125; public float getY() &#123; return y; &#125; public void setY(float y) &#123; this.y = y; &#125; &#125; 然后是自定义的PointEvaluator类，这里我们获取动画执行时的x轴跟y轴的坐标，并返回一个Point对象。 12345678910111213/** * Point的估值器 * Created by zhangyongming on 2017/1/11. */ public class PointEvaluator implements TypeEvaluator&lt;Point&gt; &#123; @Override public Point evaluate(float fraction, Point startValue, Point endValue) &#123; float resultX = startValue.getX() + (endValue.getX() - startValue.getX()) * fraction; float resultY = startValue.getY() + (endValue.getY() - startValue.getY()) * fraction; return new Point(resultX,resultY); &#125; &#125; 接下来就是给ImageView使用了： 1234567891011ValueAnimator valueAnimator = ValueAnimator.ofObject(new PointEvaluator(), new Point(50, 50), new Point(500, 500)); valueAnimator.setDuration(2000); valueAnimator.start(); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; Point point = (Point) valueAnimator.getAnimatedValue(); mImageView.setX(point.getX()); mImageView.setY(point.getY()); &#125; &#125;); 基本上的实现思路就是这样的。 PropertyValuesHolder的用法propertyValuesHolder可以用于动画的组合执行，使用起来很简单，如下示例： 1234PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 1f, 0f, 1f); PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1f, 0f, 1f); PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1f, 0f, 1f); ObjectAnimator.ofPropertyValuesHolder(mImageView, alpha, scaleX, scaleY).setDuration(2000).start(); 这样就能很容易地实现三个动画的组合播放了。 ViewPropertyAnimator的用法ViewPropertyAnimator可以用一种很简便的方式让控件执行动画，该类提供了链式调用进行多个属性同时变化的动画，更加简洁方便我们操作组合动画（多个属性同时进行变化），它可以为同时动画提供更好的性能。ViewPropertyAnimator在动画进行的时候只对多个属性的变化进行一次invalidate调用，而不是对变化每个属性进行调用（n个ObjectAnimator就会进行n次属性变化，就有n次invalidate）。当然这个类的调用方式更方便，调用对应属性方法传一个属性值就可以自动实现动画。每个属性方法都有两种调用形式，例如 alpha(float value) 和alphaBy(float value)，前者是变化到多少，后者是变化多少。 ViewPropertyAnimator没用提供公开的构造方法，通过调用view的animate()获取引用。 总而言之： ViewPropertyAnimator操作View对象的。 提供链式调用设置多个属性动画，这些动画同时进行的。 更好的性能，多个属性动画是一次同时变化，只执行一次UI刷新。 每个属性提供两种类型方法设置。 ViewPropertyAnimator只能通过View的animate()获取引用进行设置。 比如让一个图片控件在1秒内由透明变为不透明： 1mImageView.animate().alpha(0f).setDuration(1000); 是不是很方便？当然也可以使用插入器，同样只需要在后面继续调用setInterpolator()方法即可： 1mImageView.animate().alpha(0f).setDuration(1000).setInterpolator(new LinearInterpolator()); 只需要使用连缀的方式使用就行，大大简化了代码，如果需要实现组合动画也一样，同样使用连缀的方式: 1mImageView.animate().alpha(0f).rotation(360).setDuration(1000).setInterpolator(new LinearInterpolator()); 可以看出我们不需要调用start()方法，这是由于ViewPropertyAnimator在将我们所有的连缀的方法初始化之后会为我们调用start()方法，使动画执行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[有关Property Animation（属性动画）的基本用法]]></title>
      <url>%2F2017%2F01%2F09%2F%E6%9C%89%E5%85%B3Property-Animation%EF%BC%88%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%EF%BC%89%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Property Animation就是通过动画的方式改变对象的属性。 基本用法 ValueAnimator是整个属性动画机制当中最核心的一个类，它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等。 ValueAnimator的用法：将值0过渡到20，变换时长为5秒，可以通过addUpdateListener()方法 添加监听来获取动画更新时值发生的变化，然后可以根据该值进行一些其他操作。 12345678910ValueAnimator valueAnimator = ValueAnimator.ofInt(0, 20); valueAnimator.setDuration(5000); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; int currentValue = (int) valueAnimator.getAnimatedValue(); Log.d(TAG, currentValue + ""); &#125; &#125;); valueAnimator.start(); ofInt()表示变化的是int值，offFloat()表示变化的是float值，这两个方法里可以传入很多个参数来实现你想要进行的变化，比如从0到20再到0，可以写成 1ValueAnimator valueAnimator = ValueAnimator.ofInt(0, 20，0); ObjectAnimator是继承自ValueAnimator的一个类，所以ValueAnimator的所有用法也适用于ObjectAnimator，ObjectAnimator可以对任意对象进行动画操作。 在这里可以使用ofFloat(Object target, String propertyName, float... values)方法对一个对象进行动画操作，同样也有相同参数的ofInt()方法来对传入对象的int值进行变化。 以下是旋转动画，其中ofFloat()方法的第二个参数是对传入的对象的哪个属性进行动画操作，理论上，该值可以为传入对象的任意属性，因为ObjectAnimator在设计的时候就不是针对View对象进行设计的，而是任意对象，它所负责的工作就是不断地向对象的某个属性赋值，然后根据属性值的改变再来决定如何展示出来。比如下面这段代码的第一句含义就是使用ObjectAnimator不断地修改ImageView的rotation属性，从0°到360°，然后ImageView对象则需要根据rotation值不断刷新显示，然后展现出旋转动画效果。 123456789// 旋转动画，从0°到360° ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(mImageView, "rotation", 0f, 360f); // 设置动画重复次数 objectAnimator.setRepeatCount(10); // 设置动画重复模式为反转 objectAnimator.setRepeatMode(ValueAnimator.REVERSE); // 设置动画时长 objectAnimator.setDuration(1000); objectAnimator.start(); 同样，以下是淡入淡出动画： 12345// 淡入淡出动画，让ImageView的alpha值从1到0再到1 ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(mImageView, "alpha", 1f, 0f, 1f); // 设置动画的时长 objectAnimator.setDuration(3000); objectAnimator.start(); 水平缩放动画： 1234// 将ImageView水平放大3倍，然后再缩小至原有大小 ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(mImageView, "scaleX", 1f, 3f, 1f); objectAnimator.setDuration(1000); objectAnimator.start(); 平移动画： 12345// 获取ImageView当前的水平位置，然后将其水平移动到-500f，然后再移动到初始位置 ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(mImageView, "translationX", mImageView.getTranslationX(), -500f, mImageView.getTranslationX()); // 设置动画时长 objectAnimator.setDuration(5000); objectAnimator.start(); 需要注意的是，缩放动画跟反转动画都是有中心点跟中心轴的，默认是控件的中心为中心点，如果需要自己设置动画的中心点则需要调用控件的setPivotX()跟setPivotY()方法设置中心点，然后显示调用invalidate()方法。 123456789// 设置中心轴 mImageView.setPivotX(0); mImageView.setPivotY(0); // 手动调用invalidate方法 mImageView.invalidate(); // 将TextView水平放大3倍，然后再缩小至原有大小 ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(mImageView, "scaleX", 1f, 3f, 1f); objectAnimator.setDuration(1000); objectAnimator.start(); 组合动画如果我们需要将几个动画组合执行，则需要借助AnimatorSet类，该类提供了几个方法用于控制动画的执行顺序，我们向play()方法中传入一个动画对象，然后通过一系列方法控制其他动画与该动画的播放顺序。 after(Animator anim) ：是将play(Animator anim)中的动画放在after(Animator anim)方法中的动画之后执行。 after(long delay)：该方法是将play(Animator anim)方法的动画延后执行，延长的时间根据传入的参数而定。 before(Animator anim)：是将play(Animator anim)中的动画放在before(Animator anim)方法中的动画之前执行。与after(Animator anim)作用相反。 with(Animator anim)：该方法是将play(Animator anim)的动画跟with(Animator anim)中传入的动画同时执行。 playTogether(Animator... items)：该方法可以将传入的多个Animator对象同时执行。 12345678910111213141516171819202122/** * 执行组合动画 * after(Animator anim) 将现有动画插入到传入的动画之后执行 * after(long delay) 将现有动画延迟指定毫秒后执行 * before(Animator anim) 将现有动画插入到传入的动画之前执行 * with(Animator anim) 将现有动画和传入的动画同时执行 */ private void playCombinedAnimation() &#123; // 淡入淡出 ObjectAnimator alphaAnimation = ObjectAnimator.ofFloat(mImageView, "alpha", 1f, 0f, 1f); // 缩放动画 ObjectAnimator scaleAnimation = ObjectAnimator.ofFloat(mImageView, "scaleY", 1f, 3f, 1f); // 平移动画 ObjectAnimator translationAnimation = ObjectAnimator.ofFloat(mImageView, "translationY", mImageView .getTranslationY(), 300f, mImageView.getTranslationY()); AnimatorSet animatorSet = new AnimatorSet(); // 同时播放淡入淡出跟缩放，然后再播放平移动画。 animatorSet.play(alphaAnimation).with(scaleAnimation).before(translationAnimation); animatorSet.setDuration(3000); animatorSet.start(); &#125; 以上代码是先执行alphaAnimation跟scaleAnimation的组合动画，然后再执行translationAnimation。 动画的监听事件 如果要对动画进行监听，则需要使用Animator类的addListener()方法并传入一个实现了AnimatorListener接口的参数，由于ValueAnimator跟AnimatorSet都是继承自Animator的，而ObjectAnimator又是继承自ValueAnimator的，所以它们都可以使用该方法添加动画的监听。实现AnimatorListener接口需要重写四个方法，我们可以根据需求在对应的方法里实现相应的逻辑处理，如下： 12345678910111213141516171819202122// 动画的监听 objectAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animator) &#123; // 动画开始时调用 &#125; @Override public void onAnimationEnd(Animator animator) &#123; // 动画结束时调用 &#125; @Override public void onAnimationCancel(Animator animator) &#123; // 动画被取消时调用 &#125; @Override public void onAnimationRepeat(Animator animator) &#123; // 动画重复执行时调用 &#125; &#125;); 如果不想一次覆写这么多的方法，那么可以在addListener()方法中传入AnimatorListenerAdapter对象，由于AnimatorListenerAdapter对象已经实现了AnimatorListener接口，所以我们只需要按需求重写其中任意一个或多个方法即可，即使一个都不重写也不会报错。如下所示： 123456objectAnimator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationStart(Animator animation) &#123; super.onAnimationStart(animation); &#125; &#125;); 使用xml编写动画：将一些常用的动画使用xml编写，可以实现复用。首先需要在res目录下新建animator文件夹，该文件夹专门用于存放动画xml文件。xml文件三种标签的对应关系分别为： 对应代码中的ValueAnimator； 对应代码中的ObjectAnimator； 对应代码中的AnimatorSet。 比如，实现从0到1的变化： 123456&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!-- 从0到1的一个平滑过渡 --&gt; &lt;animator xmlns:android="http://schemas.android.com/apk/res/android" android:valueFrom="0" android:valueTo="1" android:valueType="floatType"/&gt; 如果需要对一个控件的属性进行操作则可以： 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!-- 将alpha的值从1过渡到0，时长1秒 --&gt; &lt;objectAnimator xmlns:android="http://schemas.android.com/apk/res/android" android:valueFrom="1" android:valueTo="0" android:valueType="floatType" android:duration="1000" android:propertyName="alpha"/&gt; 如果需要实现组合动画则： 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:ordering="together"&gt; &lt;objectAnimator android:duration="1500" android:propertyName="rotation" android:repeatCount="1" android:repeatMode="reverse" android:valueFrom="0" android:valueTo="360" android:valueType="floatType" /&gt; &lt;set android:ordering="sequentially"&gt; &lt;objectAnimator android:duration="1500" android:propertyName="scaleY" android:valueFrom="1" android:valueTo="3" android:valueType="floatType" /&gt; &lt;objectAnimator android:duration="1500" android:propertyName="scaleY" android:valueFrom="3" android:valueTo="1" android:valueType="floatType" /&gt; &lt;/set&gt; &lt;/set&gt; 组合动画中set节点下的android:ordering属性就是控制动画执行顺序的: together表示该set标签下的动画是同时执行的 sequentially表示该set标签下的动画是顺序按编写顺序执行的 动画编写完成后需要在代码中加载使用，使用AnimatorInflater的loadAnimator()方法，将动画文件加载后赋给animator对象，然后再使用Animator对象的setTarget()方法传入需要执行动画的目标对象，然后调用start()方法执行动画。 123Animator animator = AnimatorInflater.loadAnimator(this, R.animator.animator_copbined); animator.setTarget(mImageView); animator.start(); 以上便是属性动画的基本用法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于Fragment的一些知识点]]></title>
      <url>%2F2017%2F01%2F03%2F%E5%85%B3%E4%BA%8EFragment%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
      <content type="text"><![CDATA[一、固定布局如果布局是固定的，不用动态添加fragment的，可以将业务逻辑写在fragment里，然后将fragment作为控件写在xml布局中。 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal" android:weightSum="2" tools:context="com.zhangym.study.fragmentstudydem.MainActivity"&gt; &lt;fragment android:name="com.zhangym.study.fragmentstudydem.FragmentA" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_weight="1" tools:layout="@layout/fragment_a" /&gt; &lt;fragment android:name="com.zhangym.study.fragmentstudydem.FragmentB" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_weight="1" tools:layout="@layout/fragment_b" /&gt; &lt;/LinearLayout&gt; 运行效果： 二、其他知识点 一般的类似京东淘宝的那种主流布局可以使用RadioGroup + FrameLayout + Fragment实现，或者RadioGroup + ViewPager + Fragment然后禁用ViewPager的滑动即可；类似可以滑动的则使用RadioGroup + ViewPager + Fragment实现。 FragmentTransaction的常用方法： transaction.add()：添加一个fragment； transaction.remove()：移除一个fragment,若被移除的fragment未添加入回退栈，则会被直接销毁。 transaction.replace(): 替换当前的fragment，相当于先remove()再add()。 transaction.hide()：隐藏当前fragment，该fragment依旧存在，并未被销毁。 transaction.show()：显示被隐藏的fragment。fragment的onHiddenChanged(boolean hidden)方法可以检测fragment的状态。 FragmentTransaction.addToBackStack(String)：将fragment添加入回退栈,这样点击返回键就不会退出当前的Activity，而是退出fragment了。 12345FragmentManager manager = getFragmentManager(); FragmentTransaction transaction = manager.beginTransaction(); transaction.add(R.id.frameLayout,new FragmentB(),"FragmentB"); transaction.addToBackStack(null); transaction.commit(); Fragment与Activity的通信： 如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法 如果Activity中未保存任何Fragment的引用，但为每个fragment在添加时设置了一个TAG，或者在布局中为Fragment设置了id,可以通过getFragmentManager.findFragmentByTag()或者findFragmentById()获得任何Fragment实例，然后进行操作。 在Fragment中可以通过onAttach(Activity)或者getActivity()取得activity。 因为要考虑Fragment的重复使用，所以必须降低Fragment与Activity的耦合，而且Fragment更不应该直接操作别的Fragment，毕竟Fragment操作应该由它的管理者Activity来决定。所以通过回调的方式，由宿主Activity或者其他Fragment决定是否处理按钮的监听事件。 fragment的实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class FragmentA extends Fragment implements View.OnClickListener &#123; private Context mContext; @Override public void onAttach(Context context) &#123; super.onAttach(context); mContext = context; &#125; /** * 设置按钮点击的回调 */ public interface FragmentAClickListener &#123; void onFragmentAClick(); &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_a, container, false); // view.findViewById(R.id.button).setOnClickListener(new View.OnClickListener() &#123; // @Override // public void onClick(View view) &#123; // FragmentManager manager = getFragmentManager(); // FragmentTransaction transaction = manager.beginTransaction(); // transaction.add(R.id.frameLayout,new FragmentB(),"FragmentB"); // transaction.addToBackStack(null); // transaction.commit(); // &#125; // &#125;); view.findViewById(R.id.button).setOnClickListener(this); return view; &#125; @Override public void onClick(View view) &#123; // 判断如果activity实现了该接口，则执行activity里实现的onFragmentAClick()方法。 if (mContext instanceof FragmentAClickListener) &#123; ((FragmentAClickListener) mContext).onFragmentAClick(); &#125; &#125; &#125; activity的实现如下： 123456789101112131415161718public class MainActivity extends AppCompatActivity implements FragmentA.FragmentAClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); FragmentManager manager = getFragmentManager(); FragmentTransaction transaction = manager.beginTransaction(); transaction.add(R.id.frameLayout, new FragmentA(), "FragmentA"); transaction.commit(); &#125; @Override public void onFragmentAClick() &#123; Toast.makeText(this, "test", Toast.LENGTH_SHORT).show(); &#125; &#125; 为了防止在activity的状态发生变化创建重复的fragment，故可以在activity的onCreate()方法里判断saveInstanceState是否为null，为null时才新建fragment。 12345678910111213141516171819202122232425public class MainActivity extends AppCompatActivity implements FragmentA.FragmentAClickListener &#123; private FragmentA mFragmentA; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState == null)&#123; mFragmentA = new FragmentA(); &#125; FragmentManager manager = getFragmentManager(); FragmentTransaction transaction = manager.beginTransaction(); transaction.add(R.id.frameLayout, mFragmentA, "FragmentA"); transaction.commit(); mFragmentA.setFragmentAClickLister(this); &#125; @Override public void onFragmentAClick() &#123; Toast.makeText(this, "test", Toast.LENGTH_SHORT).show(); &#125; &#125; 效果图如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git&GitHub的使用]]></title>
      <url>%2F2016%2F12%2F22%2FGit-GitHub%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[一、 前言1. 简介Git是Linux作者Linus Torvalds开发的一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 2. 特点1) 全球知名公司都在用众所周知，知名的全球最大同性交友平台GitHub只接受git作为唯一版本库格式进行托管。也就说，GitHub上面能见到的开源项目的公司都使用过或者正在使用git，比如国外的Google，Facebook，Square公司，国内的百度，阿里巴巴，360等都在GitHub上有很多开源项目。那么，我们有什么理由不接受它呢？ 2) 因为它真的很好很强大git与其他版本控制系统的区别： Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统（CVS，Subversion，Perforce，Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容，请看图 Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。Git 的工作方式类似下图 这是 Git 同其他系统的重要区别。它完全颠覆了传统版本控制的套路，并对各个环节的实现方式作了新的设计。Git 更像是个小型的文件系统，但它同时还提供了许多以此为基础的超强工具，而不只是一个简单的CVS。 在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用 CVS 的话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。 举个例子，如果要浏览项目的历史更新摘要，Git 不用跑到外面的服务器上去取数据回来，而直接从本地数据库读取后展示给你看。所以任何时候你都可以马上翻阅，无需等待。如果想要看当前版本的文件和一个月前的版本之间有何差异，Git 会取出一个月前的快照和当前文件作一次差异运算，而不用请求远程服务器来做这件事，或是把老版本的文件拉到本地来作比较。 3) 使用git更安全在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。这项特性作为Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。 Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起来就像是： Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。 二、 安装git各平台的下载地址：https://git-scm.com/downloads Windows：点击下载的exe文件，一路下一步，几乎不用修改默认配置即可。完成之后再开始菜单下可以看见git的文件夹，里面包含命令行工具跟GUI工具，看个人喜好用哪个。 Linux：Ubuntu下安装使用命令 sudo apt-get install git 安装完成后使用git --version命令检查是否安装成功。 Mac：mac系统自带，貌似不用安装，检查是否安装方式同Linux。 三、 日常使用1. 创建版本库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 初始化一个Git仓库，使用git init命令。 然后是基本的配置，使用git config --global user.name “zhangym”配置用户名，使用git config --global user.email yongming9011@163.com配置邮件地址。 然后添加文件到Git仓库，分两步： 第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件；如果一次修改文件过多，有三个命令可以参考：git add -A 提交所有变化,包括修改的，删除的，新建的文件。 git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)。git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件。如果之前使用了gita dd 命令将文件提交到了缓冲区，但是暂时没有使用git commit命令，然后对文件进行了修改，此时如果需要提交则需要使用git commit -am “提交描述”，如果使用git commit -m “提交描述”会出现fatal: Paths with -a does not make sense.的错误提示。 第二步，使用命令git commit -m “say some words”，完成。简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 git commit -m &quot;xxx&quot; 只会提交添加到缓存区的文件（只提交添加的)；git commit -a -m &quot;xxx&quot;能提交修改过，但是没有添加到缓存区的文件（修改过的就能提交）。 l 关于工作区跟暂缓区工作区（Working Directory）：创建版本库时新建的那个目录，就是一个工作区。 版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 所以，同一个文件，如果已经执行了add命令，然后再修改，再执行commit命令，其实修改是无效的。 2. 管理版本库要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 版本回退Ø 使用回退命令前，用git log可以查看提交历史，以便确定要回退到哪个版本。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数，即git log –pretty=oneline 和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，大家每人都有一个完成的版本库，且每个人手上修改的东西都不一样，如果大家都用1，2，3……作为版本号，你手上的1版本跟我手上的1版本内容肯定不一样，那肯定就冲突了。 Ø Git允许我们在版本的历史之间回退，使用命令git reset --hard HEAD^ 或者git reset --hard commit_id。Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 Ø 如果后悔回退了，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 其实git内部记录各个操作是通过一种类似游标的方式： 每一次操作相当于把HEAD移动过来移动过去，所以速度特别快。而SVN等其他的则是相当于修改文件，所以效率上比git要差。 3. 管理修改 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，使用git checkout -- &lt;file&gt;命令，命令git checkout -- readme.md意思就是，把readme.md文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。git checkout -- file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令。当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时（执行了add命令），想丢弃修改，分两步，第一步用命令git reset HEAD file可以把暂存区的修改撤销掉，重新放回工作区，这样就回到了场景1，第二步按场景1操作。git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。（git reset --hard commit_id）。 4. 删除文件在Git中，删除也是一个修改操作，一般情况下，通常直接在文件管理器中把没用的文件删了，或者用rm命令删了。 使用git status 命令，git会发现工作区跟版本库不同步了 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit，现在，文件就从版本库中被删除了。 另一种情况是删错了，因为缓存区里还有呢，所以可以使用git checkout -- test.md很轻松地把误删的文件恢复到最新版本。 git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 5. 远程仓库GitHub将代码托管到GitHub，当然，仅限个人项目，公司项目需慎重（小心公司起诉你）。 1) 从本地仓库关联远程仓库Ø 首先，在https://github.com/注册一个账号，相信大家都会的。 Ø 然后在命令窗口输入： ssh-keygen -t rsa -C&quot;yongming9011@163.com&quot; 然后一路回车，如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSHKey的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人，打开id_rsa.pub.pub，复制里面的内容。 Ø 点击github上账户头像，在弹出的列表中点击Settings，然后在弹出的界面左侧点击SSH and GPG keys 然后在打开的配置界面点击 New SSH key 然后打开添加界面，将刚才复制的信息添加进去，点击Add SSH key生成 在命令行输入ssh -T git@github.com验证。 Ø 点击头像左侧的➕按钮，选择New repository新建仓库。 Ø 填写完整的信息，然后点击Create repository按钮创建项目。 Ø 创建成功后就会跳转至该项目主界面，点击右侧的Clone or download按钮，下方显示的就是该项目的远程仓库地址。点击地址后方的按钮，可以复制地址到剪切板。 Ø 在本地仓库使用命令git remote add origin &lt;远程服务地址&gt; 将远程仓库与本地仓库关联。如果要解除与远程的关联，则使用git remote remove &lt;名称&gt; Ø 使用git push -u origin master命令第一次将本地文件提交到远程仓库，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。如果远程仓库有文件使用如上命令会提示错误 此时需要使用命令git pull origin master拉取远程仓库的内容到本地。 如果使用git pull origin master拉取时出现以上问题的话，直接使用 git pull origin master --allow-unrelated-histories命令解决。 Ø 然后就可以愉快的使用github了，此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改。 2) 先有远程仓库，后有本地仓库（常规使用的方式） github的远程仓库创建方式如上，但是在创建时将下方的一些配置也勾选上，添加过滤文件跟协议。此时创建的仓库会默认自带.gitignore文件，LICENSE,README.md文件 然后在本地新建一个目录，使用git clone xxx(远程仓库地址)命令将远程仓库克隆到本地。这样远程的也就跟本地的关联起来的 Tips：github支持多种协议，包括https跟ssh等，通常建议使用git原生就支持的ssh协议，主要是速度快，还有个原因就是使用https需要每次都输用户名跟密码，比较麻烦。 6. 分支管理1) 创建与合并分支在版本回退里，已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上 所以，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。 Ø 创建分支：git checkout –b dev创建并切换到dev分支，git checkout命令加上-b参数表示创建并切换，相当于以下两条命令 git branch dev 创建dev分支 git checkout dev 切换到dev分支 然后使用git branch 命令查看当前所有分支，该命令会列出所有分支，当前分支前面会标一个*号 此时我们正处于dev分支上，然后我们修改dev分支的内容并提交，注意，我们的修改跟提交并不影响master分支。 然后再切换到master分支查看mm.txt文件，会看不到刚才添加的内容。因为刚才的内容是在dev分支上提交的。如下图 此时，我们只需要将dev分支合并到master即可，使用命令：git merge dev 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。合并完成后，就可以放心地删除dev分支了,使用git branch –d dev命令删除，或者使用git branch –D dev强制删除。 总结： Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 2) 解决冲突做个实验，我们先在创建个dev分支，然后切换回master分支，修改mm.txt文档，然后commit提交。然后再切换到dev分支，修改mm.txt，完成之后commit。 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。 明显git告诉我们合并失败了，并且告诉我们在mm.txt文件上发生了冲突，并且需要我们去修复冲突，此时去打开仓库的mm.txt，会发现是这样的 其中&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 跟 ======= 之间的内容是当前分支的，=======跟&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间的内容是发生冲突的地方，然后我们需要把这些内容合并处理下并再次add ，commit即可。 使用 git log --graph 可以查看分支合并图。 3) 分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 加上--no-ff参数的git merge表示禁用Fastforward，就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。然后使用git log --graph 查看合并 如果使用Fast-forword方式可以看出，是没有历史记录的。 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 4) bug分支软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？ 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。 然后使用git status查看会发现工作区是干净的，其实只是我们隐藏了现在，因此可以放心地创建分支来修复bug。 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：假定我们现在需要修复issue-1的bug，我们可以从master上新建一个issue-1分支，然后修复问题，合并分支并删除分支。 现在我们需要恢复工作现场，有两种方式：一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容也删了。 5) Feature分支软件开发中，总有无穷无尽的新的功能要不断添加进来。 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。顺利的话，跟bug分支是类似的，直接合并删除就OK，但是，就在此时，接到上级命令，因经费不足，新功能必须取消！虽然白干了，但是这个分支还是必须就地销毁。 可以看出Git友情提醒，feature分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature。 总结： 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。 6) 多人协作当从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用git remote 或者，用git remote -v显示更详细的信息. 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支： 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上。使用命令git push origin master 如果要推送其他分支，则将master改为其他分支名即可。 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支： 多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆, 默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看: 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支. 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程： 然后你在别的机子上也对该文件进行了修改并试图推送，然后你会发现发生了冲突，因为远程仓库的文件已经被你的小伙伴更新了： 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：使用命令git branch --set-upstream-to=origin/dev 然后再pull，会提示有冲突，此时只需要去解决下冲突，然后再push即可，具体做法参考解决冲突章节。 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to=origin/dev这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结： 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，先切换到需要关联的分支下，然后再使用git branch --set-upstream-to=origin/dev 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 7. 标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。 有人会问，Git有commit，为什么还要引入tag？ “请把上周一的那个版本打包发布，commit号是6a5819e…” “一串乱七八糟的数字不好找！” 如果换一个办法： “请把上周一的那个版本打包发布，版本号是v1.2” “好的，按照tag v1.2查找commit就行！” 所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 1) 创建标签在Git中打标签非常简单，首先，切换到需要打标签的分支上，然后，敲命令git tag &lt;name&gt;就可以打一个新标签。使用命令git tag可以查看所有标签 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周三了，但应该在周二打的标签没有打，怎么办？ 方法是找到历史提交的commitid，然后打上就可以了：首先找到commitid 比方说要对add merge这次提交打标签，它对应的commitid是8c105a2，敲入命令：git tag v0.7 8c105a2 即可 使用git tag 查看所有标签，注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show &lt;tagname&gt;查看标签信息： 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 还可以通过-s用私钥签名一个标签，具体感兴趣的可以自行Google，百度。 总结： 命令git tag &lt;name&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； git tag -a &lt;tagname&gt; -m &quot;……&quot;可以指定标签信息； git tag -s &lt;tagname&gt; -m &quot;………&quot;可以用PGP签名标签； 命令git tag可以查看所有标签。 2) 操作标签如果标签打错了，也可以删除,使用命令 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin &lt;tagname&gt;，或者使用命令git push origin --tags 一次性推送所有尚未推送到远程仓库的标签。 如果标签已经推送到远程，要删除远程标签就麻烦一点，先使用命令git tag -d v0.9 从本地删除，然后使用命令git push origin :refs/tags/v0.9从远程删除。 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。 总结： 命令git push origin &lt;tagname&gt;可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d &lt;tagname&gt;可以删除一个本地标签； 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。 Tips: 点击这里进行word文档下载！🏃🏻🏃🏻🏃🏻]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio常用快捷键]]></title>
      <url>%2F2016%2F12%2F17%2FAndroid-Studio%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"><![CDATA[Android Studio自发布第一版以来已经三年多了，现在已经相当稳定了，并且Google已经停止了对eclipse的支持，so，还在用eclipse的小伙伴们，也是时候换工具了。 本打算写一篇Android Studio的简单使用的教程，由于时间有限，加上本人使用Android Studio时间不是很久，水平有限，故暂时搁置。本文主要记录Android Studio的常用快捷键。 建议大家使用原生的Android Studio的快捷键，而不要修改快捷键为eclipse模式等其他模式，主要是因为Android Studio是基于JetBrains的IntelliJ IDEA开发的，JetBrains旗下有一众非常优秀的IDE，类似大名鼎鼎的IntelliJ IDEA ，PHPStorm，PyCharm，WebStorm等几乎各个领域的开发工具，也就是说你学会了其中一款的快捷键，再上手其他的就很简单了。以下是一些最基本的常用快捷键，需要查看所有的快捷键请去settings --&gt; keymap 里进行查看修改。注意:Mac系统需要将所有的ctrl换成command，alt换成option。 常用快捷键 Action Mac OSX Win/Linux 代码提示 Shift + 空格 / ctrl + alt + 空格 导包,提示错误 Alt + enter 修改变量名（全部） Shift + F6 复制当前行到下一行 Command + D 调出菜单，setter getter constructor等 Ctrl + enter 调出surround with菜单 alt + command + T 注释代码(//) Cmd + / Ctrl + / 注释代码(/**/) Cmd + Option + / Ctrl + Alt + / 格式化代码 Cmd + Option + L Ctrl + Alt + L 清除无效包引用 Option + Control + O Alt + Ctrl + O 查找 Cmd + F Ctrl + F 查找+替换 Cmd + R Ctrl + R 上下移动代码 Option + Shift + Up/Down Alt + Shift + Up/Down 删除行 Cmd + Delete Ctrl + Y 扩大缩小选中范围 Option + Up/Down Ctrl + W/Ctrl + Shift + W 快捷生成结构体 Cmd + Option + T Ctrl + Alt + T 快捷覆写方法 Ctrl + O Ctrl + O 快捷定位到行首/尾 Cmd + Left/Right Ctrl + Left/Right 折叠展开代码块 Cmd + Plus,Minus Ctrl + Plus/Minus 折叠展开全部代码块 Cmd + Shift + Plus,Minus Ctrl + Shift + Plus,Minus 文件方法结构 Cmd + F12 Ctrl + F12 查找方法调用的位置 Ctrl + Option + H Ctrl + Alt + H 大小写转换 Cmd + Shift + U Ctrl + Shift + U 调试快捷键 Action 快捷键 单步执行,不进入方法；逐过程，相当于下一步 F8 单步执行，进入方法 F7 debug时选中查看值 alt+f8 这个是强制进入代码 alt+shift+f7 相当于eclipse的f8跳到下一个断点，也相当于eclipse的f7跳出函数 shift+f8 执行下一轮 alt + F9 如果想要隐藏所有工具栏、工具窗口和编辑器选项卡，请点击 View &gt; Enter Distraction Free Mode。 此操作可启用无干扰模式。 要退出”无干扰模式”，请点击 View &gt; Exit Distraction Free Mode。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android6.0权限的处理]]></title>
      <url>%2F2016%2F12%2F17%2FAndroid6-0%E6%9D%83%E9%99%90%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[关于Android6.0，在申请权限的时有以下需要注意的地方： 若用户勾选了不再提示的选择框之后，是不会再弹出系统的权限申请提示框，这就麻烦了，此时我们需要提示用户去设置里为app开启相应的权限。具体做法：在onRequestPermissionsResult()方法中判断用户拒绝权限后shouldShowRequestPermissionRationale()的值，该值若为false，则表示用户勾选了不再提示，此时，我们可以进行相应的提示。 关于shouldShowRequestPermissionRationale()： 从字面意思可以看出，这个方法是告诉我们是否应该向用户解释我们申请该权限的原因，即告诉用户我们为什么要申请该权限。在app第一次安装的时候。这个方法会返回false，因此你可以直接请求任何需要的权限。如果用户以前拒绝了一个请求，这个方法将返回true，表示你应该向用户解释了。那样的话你应该考虑在再次触发权限对话框之前显示一个解释请求用途之类的信息。此后，如果用户一直点击拒绝，则该值一直为true。 最终，当app完全没有机会被授权的时候，即用户选中了不再显示的复选框之后，shouldShowRequestPermissionRationale()则返回false，这里的意思很明显，用户都已经勾选不再显示了，我们也就不需要再解释了。 然而，我们便可以利用这个方法的返回值进行判断用户是否拒绝并勾选不再显示，当用户拒绝并勾选不再提示后，则我们可以在onRequestPermissionsResult()方法中判断用户拒绝权限后该值是否为false，如果为false，那么表示用户拒绝了权限并勾选不再显示。 123456789@Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (grantResults[0] == PackageManager.PERMISSION_DENIED)&#123; if (ActivityCompat.shouldShowRequestPermissionRationale(this,permissions[0]))&#123; // 用户拒绝，并勾选了 不再显示 &#125; &#125; &#125; 建议使用GitHub上严振杰大神封装好的库AndPermission，还是比较方便的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RxJava学习笔记]]></title>
      <url>%2F2016%2F12%2F14%2FRxJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[RxJava的常用操作符 just(T...):将传入的参数依次发送出来,快捷创建创建事件队列的方法 1Observable.just("hello","world”); 等同于 12345678Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("hello"); subscriber.onNext("world"); subscriber.onCompleted(); &#125; &#125;) from(T[]) / from(Iterable) : 将传入的数组或 Iterable 拆分成具体对象后，依次发送出 12String[] words = new String[]&#123;"hello","world"&#125;; Observable.from(words); 等同于 123456789Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("hello"); subscriber.onNext("world"); subscriber.onCompleted(); &#125; &#125;) Rxjava的知识点RxJava的基本实现方式： Observable即被观察者，它决定了什么时候触发事件以及触发怎样的事件。 Observer即观察者，它决定了事件触发的时候将有怎样的行为。 123456789101112131415161718192021222324Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("hello"); subscriber.onNext("world"); subscriber.onCompleted(); &#125; &#125;) .subscribe(new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.d(TAG,"onCompleted") &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onNext(String s) &#123; Log.d(TAG,s); &#125; &#125;); 除了Observer接口之外，RxJava还内置了一个实现了Observer的抽象类：Subscriber. 123456789101112131415161718192021222324Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("hello"); subscriber.onNext("world"); subscriber.onCompleted(); &#125; &#125;) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.d(TAG, "onCompleted"); &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onNext(String s) &#123; Log.d(TAG, s); &#125; &#125;); 两种使用方式是一样的。它们的区别对于使用者来说主要有两点： Subscriber新增加了onStart()方法，它会在subscribe刚开始事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或者重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作有线程要求（如弹出一个转菊花的ProgressBar,就必须在主线程执行），onStart()方法就不适用了，因为它总是在subscribe所发生的线程被调用，而不能指定线程。需要在指定线程来做准备工作，可以使用doOnSubscribe()方法。 Subscriber实现了另一个方法unsubscribe(),这个方法被调用后，Subscriber将不再接收事件。一般这个方法调用前，可以使用isUnsubscribed()先判断一下状态。unsubscribe()主要用于解除引用关系，以避免内存泄露的发生。 Action 1234567891011121314151617181920212223242526272829Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; // next() Log.d(TAG,s); &#125; &#125;; Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; // ERROR &#125; &#125;; Action0 onCompletedAction = new Action0() &#123; @Override public void call() &#123; // complete Log.d(TAG,"onCompleted"); &#125; &#125;; // 自动创建Subscriber,并使用onNextAction来定义onNext()； observable.subscribe(onNextAction); // 自动创建Subscriber,并使用onNextAction onErrorAction 来定义onNext() onError() observable.subscribe(onNextAction,onErrorAction); // 自动创建Subscriber,并使用onNextAction onErrorAction onCompletedAction来定义onNext() onError() onCompleted() observable.subscribe(onNextAction,onErrorAction,onCompletedAction); Action0是RxJava的一个接口，它只有一个方法call(),这个方法是无参数无返回值的；由于onCompleted()方法也是无参数无返回值得，因此Action0可以被当成一个包装对象，将onCompleted()的内容打包起来将自己作为一个参数传入subscribe()以实现不完整定义的回调。Action1也是一个接口，它同样只有一个方法call(T t)，这个方法也无返回值，但是有一个参数；与Action0同理，由于onNext(T t)和onError(Throwable error)也是单参数无返回值的，因此Action1可以将onNext(t)和onError(error)打包。 RxJava提供了多个ActionX形式的接口，他们可以用以包装不同的无返回值的方法。ActionX的方法是无返回值的。 例如，将字符串数组names中的所有字符串依次打印出来： 12345678String[] names = new String[]&#123;"John","Jim","Tom","Alexander"&#125;; Observable.from(names) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d(TAG,s); &#125; &#125;); 线程控制 —— Scheduler 在不指定线程的情况下，RxJava遵循的是线程不变的原则，即：在哪个线程调用subscribe()，就在哪个线程产生事件；在哪个线程产生事件就在哪个线程消费事件。如果需要切换线程，就需要用到Scheduler（调度器）。RxJava通过它来指定每一段代码应该运行在什么样的线程。RxJava已经内置了几个Scheduler: Schedulers.immediate():直接在当前线程中运行，相当于不指定线程。这是默认的Scheduler。 Schedulers.newThread():总是启用新线程，并在新线程执行操作。 Schedulers.io():I/O操作（读写文件，读写数据库，联网等）所使用的Scheduler。行为模式跟newThread()的差不多，区别在于io()的内部实现是一个无数量上线的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。不要把计算工作放在io()中，可以避免创建不必要的线程。 Schedulers.computation()：计算所使用的Scheduler。这个计算指的是cpu密集型计算，即不会被I/O等操作限制性能的操作，例如图形的计算。这个Scheduler使用的是固定的线程池，大小为CPU核心数。不要把I/O操作放在computation()中，否则I/O操作的等待时间会浪费cpu。 另外，Android还有一个专用的AndroidSchedulers.mainThread()，它制定的操作将在Android主线程运行。 有了这几个Scheduler，就可以使用subscribeOn()和observeOn()两个方法来对线程进行控制。subscribeOn()指定subscribe()所发生的线程，即Observable.OnSubscribe被激活时所处的线程，或者叫做事件产生的线程。observeOn()指定Subscriber所运行在的线程。或者叫做事件的消费的线程。 123456789101112String[] names = new String[]&#123;"John","Jim","Tom","Alexander"&#125;; Observable.from(names) // 指定names发生的线程在io()线程，被创建的事件的内容names会在io线程发出 .subscribeOn(Schedulers.io()) // 指定Subscriber的回调发生在主线程，故打印将发生在主线程。 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d(TAG,s); &#125; &#125;); 事实上，这种在subscribe()之前写上两句subscribeOn(Scheduler.io())和observeOn(AndroidSchedulers.mainThread())的使用方式非常常见，它适用于多数的“后台线程取数据，主线程显示”的程序策略。 变换 所谓变化，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。 observeOn()指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次observeOn()即可。不过，不同于observeOn(),subscribeOn()的位置放在哪里都可以，但它是只能调用一次的。当使用了多个subscribeOn()的时候，只有第一个subscribeOn()起作用。 然而，虽然超过一个的subscribeOn()对事件处理的流程没有影响，但在流程之前确是可以利用的。那就是与Subscriber.onStart()方法相对应的Observable.doOnSubscribe()方法，它和Subscriber.onStart()同样是在subscribe()调用后且在事件发送前执行，但区别在于它可以指定线程。默认情况下，doOnSubscribe()执行在subscribe()发生的线程。如果在doOnSubscribe()之后有subscribeOn()方法，则它将执行离他最近的subScribeOn()所指定的线程。如下，在doOnSubscribe()后面跟一个subscribeOn()，就能指定准备工作的线程了。 123456789101112131415161718Observable.just("hello","world") .subscribeOn(Schedulers.io()) .doOnSubscribe(new Action0() &#123; @Override public void call() &#123; // 需要在主线程执行 showProgressBar(); &#125; &#125;) // 指定主线程 .subscribeOn(AndroidSchedulers.mainThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d(TAG,s); &#125; &#125;); Func 123456789101112131415Observable.just("images/sky.png") .map(new Func1&lt;String, Bitmap&gt;() &#123; @Override public Bitmap call(String s) &#123; return getBitmapFromFile(s); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; iv.setImageBitmap(bitmap); &#125; &#125;); 这里出现了一个叫做Func1的类。它和Action1非常相似，也是RxJava的一个接口，用于包装含有一个参数的方法。Func跟Action的区别在于，Func包装的是有返回值的方法。另外，和ActionX一样，FuncX也有多个，用于不同参数个数的方法。 map():事件对象的直接变换。它是RxJava最常用的变换。 flatMap():它也是把传入的参数转化之后返回另一个对象。但是跟map()不同的是，flatMap()返回的是个Observable对象，并且这个Observable对象并不是被直接发送到了Subscriber的回调方法中。 throttleFirst()：在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听事件。 ———————————♥︎举个栗子♥︎———————————— 假如我现在需要联网加载百度的页面，然后将返回的内容显示在一个TextView上，就可以这么写： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class MainActivity extends AppCompatActivity &#123; private TextView tvFirst; private TextView tvResult; private ProgressDialog dialog; private static final String TAG = "zhangym"; private Observable&lt;String&gt; mObservable; private Subscriber&lt;String&gt; mSubscriber; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvFirst = (TextView) findViewById(R.id.tv_fist); tvResult = (TextView) findViewById(R.id.tv_result); tvFirst.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; showResponseResult(); &#125; &#125;); &#125; private void showResponseResult() &#123; // 创建被观察者 mObservable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; HttpURLConnection connection = null; try &#123; URL url = new URL("https://www.baidu.com/"); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("GET"); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); InputStream is = connection.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); StringBuilder sb = new StringBuilder(); String line = null; while ((line = reader.readLine()) != null) &#123; sb.append(line); &#125; // 发送事件 subscriber.onNext(sb.toString()); subscriber.onCompleted(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); // 创建观察者 mSubscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.d(TAG, "onCompleted"); dialog.dismiss(); &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onNext(String s) &#123; tvResult.setText(s); &#125; &#125;; // 指定联网操作在io线程 mObservable.subscribeOn(Schedulers.io()) // 事件发送前的准备工作 .doOnSubscribe(new Action0() &#123; @Override public void call() &#123; dialog = new ProgressDialog(MainActivity.this, ProgressDialog.THEME_DEVICE_DEFAULT_LIGHT); dialog.setProgressStyle(ProgressDialog.STYLE_SPINNER); dialog.setIndeterminate(true); dialog.show(); &#125; &#125;) // 指定doOnSubscribe()的线程为UI线程 .subscribeOn(AndroidSchedulers.mainThread()) // 指定Subscriber的线程为UI线程，即在UI线程显示结果 .observeOn(AndroidSchedulers.mainThread()) // 订阅事件 .subscribe(mSubscriber); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // 取消订阅，防止内存泄露 if (!mSubscriber.isUnsubscribed())&#123; mSubscriber.unsubscribe(); &#125; &#125; &#125; 运行效果: 由于网速较快，所以ProgressDialog一闪而过，gif图上面看不出来。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java中回调的理解]]></title>
      <url>%2F2016%2F12%2F12%2FJava%E4%B8%AD%E5%9B%9E%E8%B0%83%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[回调在Java中运用的相当广泛，类似Android中的控件点击监听事件setOnClickListener()方法就是典型的回调。回调是什么？关于回调的定义通俗地说就是：A类调用B类中的某个方法，然后B类中反过来调用A类中的方法D,D这个方法就叫做回调方法。在Java中回调的这个方法D一般是接口中定义，然后A类通过实现接口的D方法。 一般回调的话需要满足以下几个条件： Class A实现接口CallBack callback ——场景1 class A中包含一个class B的引用b ——场景2 class B有一个参数为callback的方法f(CallBack callback) ——场景3 A里的B的引用调用B的方法 f(CallBack callback) ——A类调用B类的某个方法C ——场景4 然后b就可以在f(CallBack callback)方法中调用A的方法 ——B类调用A类的某个方法D ——场景5 接下来我将通过一个demo说明，假设我需要实现一个类似下载完成的监听方法。具体就是Download这个类可以实现下载，给它的构造方法中传入我们需要下载的数据量，其开始下载，并且提供了下载完成的监听，当下载成功或者失败后调用对应的回调方法。 首先，定义一个下载完成的接口，接口中包含了下载完成后的两个回调方法。 123456789101112131415/** * 下载完成的回调接口 * Created by zhangyongming on 2016/12/12. */ public interface OnDownloadCompleted &#123; /** * 下载成功的回调 */ void onSuccess(); /** * 下载失败的回调 */ void onFail(); &#125; 然后是Download类：Download类有一个setOnDownloadCompletedListener(OnDownloadCompleted onDownloadCompleted)方法（相当于场景3），在该方法中模拟了下载过程，并且根据下载的结果调用了Test类的onSucess()跟onFail()方法（相当于场景5，这两个方法是Test类实现了OnDownloadCompleted接口后实现的方法），在这里我们模拟如果下载结果为100则为下载成功，否则下载失败。 123456789101112131415161718192021222324252627282930/** * 模拟下载的类，里面有一个设置下载完成的监听 * Created by zhangyongming on 2016/12/12. */ public class Download &#123; private int progress; public Download(int progress) &#123; this.progress = progress; &#125; // class B有一个参数为callback的方法f(CallBack callback) ——场景3 public void setOnDownloadCompletedListener(OnDownloadCompleted onDownloadCompleted) &#123; for (int i = 0; i &lt;= progress; i++) &#123; System.out.println("下载进度： " + i + "%"); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 然后b就可以在f(CallBack callback)方法中调用A的方法 ——B类调用A类的某个方法D ——场景5 if (progress == 100) &#123; onDownloadCompleted.onSuccess(); &#125; else &#123; onDownloadCompleted.onFail(); &#125; &#125; &#125; 然后是Test类方法：Test类实现了OnDownloadCompleted接口，实现了onSuccess()方法跟onFail()方法（场景1）；Test类包含了Download类的引用（场景2），Download的实例调用了setOnDownloadCompletedListener()方法（场景4）。 12345678910111213141516171819202122232425262728293031323334/** * Class A实现接口CallBack callback ——场景1 * Created by zhangyongming on 2016/12/12. */ public class Test implements OnDownloadCompleted &#123; public static void main(String[] args) &#123; // class A中包含一个class B的引用b ——场景2 Download download = new Download(20); // A里的B的引用调用B的方法 f(CallBack callback) ——A类调用B类的某个方法C ——场景4 download.setOnDownloadCompletedListener(new Test()); &#125; @Override public void onSuccess() &#123; System.out.println("┏━━━━━┳━━━━━┓"); System.out.println("┃ ┃ ┃"); System.out.println("┃ ┃"); System.out.println("┣━ 下载完成 ━┫"); System.out.println("┃ ┃"); System.out.println("┃ ┃ ┃"); System.out.println("┗━━━━━┻━━━━━┛"); &#125; @Override public void onFail() &#123; System.out.println("┏ ━ ━ ┳ ━ ━ ┓"); System.out.println(" "); System.out.println("┃ ┃"); System.out.println(" 下载失败 "); System.out.println("┃ ┃"); System.out.println(" "); System.out.println("┗ ━ ━ ┻ ━ ━ ┛"); &#125; &#125; 上述demo我们输入一个int值之后，变开始进行循环，模拟下载过程，然后根据下载结果调用相应的方法展示数据。输出结果如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio添加日志过滤]]></title>
      <url>%2F2016%2F12%2F07%2FAndroid-Studio%E6%B7%BB%E5%8A%A0%E6%97%A5%E5%BF%97%E8%BF%87%E6%BB%A4%2F</url>
      <content type="text"><![CDATA[点击下方的 Android Monitor 点击右侧的选项菜单 点击菜单下拉列表中的 Edit Filter Configuration，打开配置界面 配置界面说明 第1部分是为这个过滤器输入名称，第2部分是一些过滤信息的配置：Log Tag 是根据log.d(&quot;XXX&quot;,&quot;show&quot;);方法中的XXX参数属性过滤，配置该项之后只会显示日志中Tag为XXX的日志;Log Message是根据日志信息过滤；Package Name是根据包名过滤；Log Level是配置显示日志的级别，一般看自己需求配置；配置完成之后点击OK确认。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac使用Dryrun做到不用运行Android Studio即可在模拟器安装预览GitHub开源项目]]></title>
      <url>%2F2016%2F12%2F06%2Fmac%E4%BD%BF%E7%94%A8Dryrun%E5%81%9A%E5%88%B0%E4%B8%8D%E7%94%A8%E8%BF%90%E8%A1%8CAndroid-Studio%E5%8D%B3%E5%8F%AF%E5%9C%A8%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AE%89%E8%A3%85%E9%A2%84%E8%A7%88GitHub%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[Dryrun是GitHub上的一个开源工具，它最强大的地方在于可以只用一行命令行即可让你运行GitHub上的项目，是不是很激动？ 通常我们需要预览GitHub上的开源项目一般会做以下几步： 找到这个项目 点击项目右侧的 Clone or download下载整个项目资源 解压缩下载下来的zip文件 导入Android Studio 同步gradle配置 如果缺少配置文件或者项目报错，则需要先排错 运行项目并预览 如果正巧是自己希望的效果，留下，如果不是，删除。 然而Dryrun只需要一行命令即可，剩下的我们都不用操心，只需安静等待即可。。。。 下面来说说如何在mac上配置吧。 首先安装前需要配置ANDROID_HOME环境变量，方法如下： 启动Terminal终端工具 输入cd ~/ 进入当前用户的home目录 或cd /Users/YourUserName 如果不存在则创建： touch .bash_profile 如果存在,就打开并编辑：open .bash_profile 在里面添加sdk的tools和platform-tools的路径,注意每个路径要用 : 隔开,并且这个路径换成你自己的刚才解压后的sdk的实际路径. 1export PATH=$PATH:/Users/youname/android/soft/adt-bundle-mac-x8664-20130522/sdk/platform-tools:/Users/youname/android/soft/adt-bundle-mac-x8664-20130522/sdk/tools(具体的文件名你自己对应) 保存关闭 更新： source .bash_profile ok了,在Terminal终端工具里输入adb -version看看,是否出来类似的界面: Android Debug Bridge version 1.0.31 如果出来了,说明已经成功了. 然后安装Dryrun，使用如下命令 $ sudo gem install dryrun 顺利的话应该就安装成功了，如果报错一般会有类似ERROR: Failed to build gem native extension. 这种错误，经过各种查资料折腾，基本上确定这个错误的一般是ruby的相关依赖文件未安装完全（网上查的，如有错误还望指正）。一般情况安装xcode后貌似就能解决，如果还是不行请自行Google或百度。安装完成后便可使用，使用方法为dryrun + 项目地址，如：dryrun https://github.com/cesarferreira/android-helloworld，接下来就是见证奇迹的时候了（图是借用dryrun官方的效果图）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Text中的属性设置]]></title>
      <url>%2F2016%2F10%2F28%2FSublime-Text%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[12345678&#123; "font_face": "Courier New", "font_size": 14.0, "update_check": false, "open_files_in_new_window": false, "hot_exit": false, "remember_open_files": false &#125; 这些配置是需要放在Preference--&gt;settings-User下的，其中 font_face 是设置字体类型的，font_size 是设置字体大小的，update_check 表示是否开启检查更新， open_files_in_new_window表示是否在新窗口中打开文件，remember_open_files 表示是否记住上次打开的文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于toolbar菜单设置了always后不显示的问题]]></title>
      <url>%2F2016%2F10%2F27%2F%E5%85%B3%E4%BA%8Etoolbar%E8%8F%9C%E5%8D%95%E8%AE%BE%E7%BD%AE%E4%BA%86always%E5%90%8E%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[我们一般写menu文件时会有如下写法： 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:id="@+id/menu011" android:title="hehe" android:icon="@mipmap/ic_launcher" android:showAsAction="always"/&gt; &lt;/menu&gt; 这样写出来的menu是不会再toolbar上面显示的，跟设置的never一样都在隐藏菜单里。解决这个问题的办法其实很简单，如下： 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;item android:id="@+id/menu_home" android:icon="@mipmap/home" app:showAsAction="always" android:title="@string/menu_home"/&gt; &lt;/menu&gt; 新增一句 1xmlns:app="http://schemas.android.com/apk/res-auto" 将 1android:showAsAction="always" 改成 1app:showAsAction="always" 即可解决。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[友盟统计sdk集成及多渠道打包]]></title>
      <url>%2F2016%2F10%2F13%2F%E5%8F%8B%E7%9B%9F%E7%BB%9F%E8%AE%A1sdk%E9%9B%86%E6%88%90%E5%8F%8A%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%2F</url>
      <content type="text"><![CDATA[友盟统计sdk集成其实很简单，先去友盟官网新建应用，然后会得到一个Appkey。 然后根据友盟的sdk集成文档在Android Studio的app目录下的build.gradle添加如下代码，集成友盟统计sdk： 12// 友盟统计的sdk compile 'com.umeng.analytics:analytics:latest.integration' 然后在AndroidManifest.xml的Application标签下配置 1234567&lt;!-- 友盟appid --&gt; &lt;meta-data android:name="UMENG_APPKEY" android:value="XXX"&gt; &lt;/meta-data&gt; &lt;!--此处配置是为了方便酷传多渠道打包 --&gt; &lt;meta-data android:value="" android:name="UMENG_CHANNEL"/&gt; 其中XXX为你自己的Appkey，UMENG_CHANNEL的值为空字符串主要是为了使用酷传的多渠道打包。然后找到程序的入口Activity，即AndroidManifest.xml里配置了如下代码的Activity 1234567&lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 在该Activity的onResum()跟onPause()方法里添加如下代码 1234567891011@Override protected void onResume() &#123; super.onResume(); MobclickAgent.onResume(this); &#125; @Override protected void onPause() &#123; super.onPause(); MobclickAgent.onPause(this); &#125; 至此，友盟统计的基本功能已经集成完毕。然后就是使用酷传进行多渠道打包了，先在酷传官网下载酷传的软件，然后申请账号，打开软件并登录 选择 上方的 工具箱 ，打开如下界面 选择 生成多渠道包，然后选择需要多渠道打包的apk文件 点击下一步，在弹出的渠道包签名对话框中选择相应的release版的keystore文件，并填写相应的信息 然后点击生成渠道包，就会出现生成渠道包的界面，完成后会在原始的apk文件所在的目录生成一个叫做 酷传智能分包 的文件夹，里面就是生成的多渠道包。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记录友盟分享，第三方登录遇到的坑]]></title>
      <url>%2F2016%2F08%2F26%2F%E8%AE%B0%E5%BD%95%E5%8F%8B%E7%9B%9F%E5%88%86%E4%BA%AB%EF%BC%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
      <content type="text"><![CDATA[最近公司项目上需要用到分享跟第三方登录，由于友盟的社会化分享在国内的口碑还挺不错，所以就集成进了项目，经历了各种坑之后，基本上算是告一段落了，现在把遇到的各种坑记录下来，希望能帮到一些遇到相同问题的猿友。 坑1：QQ第三方登录的坑 QQ第三方登录需要你在腾讯开放平台申请一个AppID及Appkey ，然后才能使用，由于同一个app使用不同的签名文件生成的AppID及Appkey是不一样的，如果你给腾讯那边上传的是一个debug版的apk，那么这个AppID及Appkey就是debug版的，然后你的第三方登录只有在使用dubug版的时候才能用，在正式包下会提示错误：应用不是最新的（100044）这个错误，所以这一点一定要注意，如果你给腾讯上传的是一个release版的apk，那么你以后的每次调试QQ登录都得用release的签名打包，我的做法是，调试的时候直接用release版的签名编译，具体参考：这篇文章的做法 。 QQ的第二个坑，QQ的接口返回的唯一码是一个叫openId的东东，其实我一直不明白它为什么不返回一个QQ号啊，因为这个东西不管在哪个平台都是唯一的，算了，不扯这些了，既然人家不给返回QQ号码自然有人家的想法，也许是为了用户隐私之类的。现在就说说这个openId，据我的理解，应该是与应用的appId还有应用的签名有关（个人理解，如有错误还望指正），所以不同的应用返回的openId是不一样的，在这里我就遇到坑了，因为我们公司iOS开发的比Android早半年，所以当初ios自己用自己的账号申请了一个ios的AppID及Appkey，现在Android这边我用公司的账号在应用宝上架的app，所以同一个QQ账号的第三方登录在ios跟Android返回的openId都不一样，经过咨询腾讯客服（QQ：800013811），告诉我只有一个办法解决，那就是把一方的应用转让给另一方，保证ios的跟Android的都在一个开发者账号下，然后再申请数据互通。。。。只有这样，才能保证相同的QQ号在两个平台的openId才能一致。 坑2：新浪微博的坑 新浪这个就比较坑了，由于我用的是Android Studio，我直接将新浪的sdk里的libs下的那些so文件夹直接拷贝到我的libs里面，原以为这样就好了（貌似在ADT下确实就好了），结果运行各种闪退，日志也没啥特殊的地方，死活不知道原因，最后纠结了两天，想着可能是so文件的原因，就百度了下Android Studio如何导入so文件，按照操作执行了之后，瞬间就好了，简直汗颜。关于在Android Studio下如何导入so文件请参考：这篇文章 或者 这篇文章。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何去掉Android Studio的注释警告]]></title>
      <url>%2F2016%2F08%2F11%2F%E5%A6%82%E4%BD%95%E5%8E%BB%E6%8E%89Android-Studio%E7%9A%84%E6%B3%A8%E9%87%8A%E8%AD%A6%E5%91%8A%2F</url>
      <content type="text"><![CDATA[我们知道，使用Android Studio（以下简称AS）如果给一个方法添加文档注释时，方法里的参数也必须添加注释，否则会有警告。如下： 其实给参数添加注释是个很好的习惯，但是如果是重写的或者实现接口的抽象方法，有时候我们不需要给参数加注释，然而AS会报警告，右侧会有黄色的横条，这些警告跟代码警告混在一起，很影响阅读，所以有时候我们需要去掉。 具体步骤：File-&gt;Settings-&gt;Editor-&gt;Inspections,在右侧找到Javadoc issues下的Declaration has Javadoc problems右侧的勾去掉然后点击Apply或者OK即可。 然后就可以看到效果了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo问题汇总]]></title>
      <url>%2F2016%2F02%2F08%2Fhexo%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
      <content type="text"><![CDATA[搜索功能不可用或点击搜索不弹出搜索框首先检查hexo文件夹下的_config.yml文件是否包含以下配置： 12345search: path: search.xml field: post format: html limit: 10000 如果配置正常的话，搜索功能还是无法使用，那么问题应该出在search.xml文件上了。在谷歌浏览器栏输入http://zhangym.me/search.xml即博客网址后添加/search.xml看看是否能正常访问，若该xml文件打开出来类似如下错误： 说明某一篇文章的内容有乱码或者其他字符导致生成的search.xml不是标准的xml文件，导致搜索功能不可用，此时只需根据对应的提示，用代码编辑器打开/hexo/public/search.xml，去问题所在的行查看并修改问题即可。修改完毕再次使用http://zhangym.me/search.xml检查，如果正常，搜索功能应该就好了。]]></content>
    </entry>

    
  
  
</search>
